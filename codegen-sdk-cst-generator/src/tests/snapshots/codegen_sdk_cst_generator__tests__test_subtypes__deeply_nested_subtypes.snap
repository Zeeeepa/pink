---
source: codegen-sdk-cst-generator/src/tests/test_subtypes.rs
expression: "crate::test_util::snapshot_string(&output)"
---
use std::sync::Arc;
use tree_sitter;
use codegen_sdk_common::*;
use subenum::subenum;
use std::backtrace::Backtrace;
use bytes::Bytes;
use derive_generic_visitor::Drive;
use ambassador::Delegate;
use codegen_sdk_cst::CSTLanguage;
use codegen_sdk_common::language::Language;
#[subenum(Declaration, FunctionDeclaration, Statement)]
#[derive(Debug, Clone, Eq, PartialEq, Drive, Hash, salsa::Update, Delegate)]
#[delegate(CSTNode<'db1>)]
pub enum NodeTypes<'db1> {
    #[subenum(Declaration, Statement)]
    ClassDeclaration(ClassDeclaration<'db1>),
    #[subenum(Statement)]
    ExpressionStatement(ExpressionStatement<'db1>),
    #[subenum(FunctionDeclaration, Declaration, Statement)]
    MethodDeclaration(MethodDeclaration<'db1>),
}
impl<'db3> From<ClassDeclaration<'db3>> for NodeTypes<'db3> {
    fn from(node: ClassDeclaration<'db3>) -> Self {
        Self::ClassDeclaration(node)
    }
}
impl<'db3> From<ExpressionStatement<'db3>> for NodeTypes<'db3> {
    fn from(node: ExpressionStatement<'db3>) -> Self {
        Self::ExpressionStatement(node)
    }
}
impl<'db3> From<MethodDeclaration<'db3>> for NodeTypes<'db3> {
    fn from(node: MethodDeclaration<'db3>) -> Self {
        Self::MethodDeclaration(node)
    }
}
impl<'db4> FromNode<'db4> for Declaration<'db4> {
    fn from_node(
        db: &'db4 dyn salsa::Database,
        node: tree_sitter::Node,
        buffer: &Arc<Bytes>,
    ) -> Result<Self, ParseError> {
        match node.kind_id() {
            0u16 => {
                Ok(
                    Self::MethodDeclaration(
                        MethodDeclaration::from_node(db, node, buffer)?,
                    ),
                )
            }
            _ => {
                Err(ParseError::UnexpectedNode {
                    node_type: node.kind().to_string(),
                    backtrace: Backtrace::capture(),
                })
            }
        }
    }
}
impl<'db4> FromNode<'db4> for FunctionDeclaration<'db4> {
    fn from_node(
        db: &'db4 dyn salsa::Database,
        node: tree_sitter::Node,
        buffer: &Arc<Bytes>,
    ) -> Result<Self, ParseError> {
        match node.kind_id() {
            0u16 => {
                Ok(
                    Self::MethodDeclaration(
                        MethodDeclaration::from_node(db, node, buffer)?,
                    ),
                )
            }
            _ => {
                Err(ParseError::UnexpectedNode {
                    node_type: node.kind().to_string(),
                    backtrace: Backtrace::capture(),
                })
            }
        }
    }
}
impl<'db4> FromNode<'db4> for Statement<'db4> {
    fn from_node(
        db: &'db4 dyn salsa::Database,
        node: tree_sitter::Node,
        buffer: &Arc<Bytes>,
    ) -> Result<Self, ParseError> {
        match node.kind_id() {
            0u16 => {
                Ok(
                    Self::MethodDeclaration(
                        MethodDeclaration::from_node(db, node, buffer)?,
                    ),
                )
            }
            _ => {
                Err(ParseError::UnexpectedNode {
                    node_type: node.kind().to_string(),
                    backtrace: Backtrace::capture(),
                })
            }
        }
    }
}
#[derive(Debug, Clone, Drive, Eq, PartialEq, salsa::Update)]
pub struct ClassDeclaration<'db> {
    #[drive(skip)]
    start_byte: usize,
    #[drive(skip)]
    end_byte: usize,
    #[drive(skip)]
    _kind: std::string::String,
    #[drive(skip)]
    start_position: Point<'db>,
    #[drive(skip)]
    end_position: Point<'db>,
    #[drive(skip)]
    buffer: Arc<Bytes>,
    #[drive(skip)]
    kind_id: u16,
    #[drive(skip)]
    is_error: bool,
    #[drive(skip)]
    named: bool,
    #[drive(skip)]
    id: usize,
}
impl<'db> FromNode<'db> for ClassDeclaration<'db> {
    fn from_node(
        db: &'db dyn salsa::Database,
        node: tree_sitter::Node,
        buffer: &Arc<Bytes>,
    ) -> Result<Self, ParseError> {
        let start_position = Point::from(db, node.start_position());
        let end_position = Point::from(db, node.end_position());
        Ok(Self {
            start_byte: node.start_byte(),
            end_byte: node.end_byte(),
            _kind: node.kind().to_string(),
            start_position: start_position,
            end_position: end_position,
            buffer: buffer.clone(),
            kind_id: node.kind_id(),
            is_error: node.is_error(),
            named: node.is_named(),
            id: node.id(),
        })
    }
}
impl<'db> CSTNode<'db> for ClassDeclaration<'db> {
    fn kind(&self) -> &str {
        &self._kind
    }
    fn start_byte(&self) -> usize {
        self.start_byte
    }
    fn end_byte(&self) -> usize {
        self.end_byte
    }
    fn start_position(&self) -> Point<'db> {
        self.start_position
    }
    fn end_position(&self) -> Point<'db> {
        self.end_position
    }
    fn buffer(&self) -> &Bytes {
        &self.buffer
    }
    fn kind_id(&self) -> u16 {
        self.kind_id
    }
    fn is_error(&self) -> bool {
        self.is_error
    }
    fn is_named(&self) -> bool {
        self.named
    }
    fn id(&self) -> usize {
        self.id
    }
}
impl<'db1> HasChildren<'db1> for ClassDeclaration<'db1> {
    type Child = Self;
    fn children(&self) -> Vec<Self::Child> {
        vec![]
    }
    fn children_by_field_name(&self, field_name: &str) -> Vec<Self::Child> {
        match field_name {
            _ => vec![],
        }
    }
    fn children_by_field_id(&self, field_id: u16) -> Vec<Self::Child> {
        match field_id {
            _ => vec![],
        }
    }
}
impl<'db> std::hash::Hash for ClassDeclaration<'db> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}
#[derive(Debug, Clone, Drive, Eq, PartialEq, salsa::Update)]
pub struct ExpressionStatement<'db> {
    #[drive(skip)]
    start_byte: usize,
    #[drive(skip)]
    end_byte: usize,
    #[drive(skip)]
    _kind: std::string::String,
    #[drive(skip)]
    start_position: Point<'db>,
    #[drive(skip)]
    end_position: Point<'db>,
    #[drive(skip)]
    buffer: Arc<Bytes>,
    #[drive(skip)]
    kind_id: u16,
    #[drive(skip)]
    is_error: bool,
    #[drive(skip)]
    named: bool,
    #[drive(skip)]
    id: usize,
}
impl<'db> FromNode<'db> for ExpressionStatement<'db> {
    fn from_node(
        db: &'db dyn salsa::Database,
        node: tree_sitter::Node,
        buffer: &Arc<Bytes>,
    ) -> Result<Self, ParseError> {
        let start_position = Point::from(db, node.start_position());
        let end_position = Point::from(db, node.end_position());
        Ok(Self {
            start_byte: node.start_byte(),
            end_byte: node.end_byte(),
            _kind: node.kind().to_string(),
            start_position: start_position,
            end_position: end_position,
            buffer: buffer.clone(),
            kind_id: node.kind_id(),
            is_error: node.is_error(),
            named: node.is_named(),
            id: node.id(),
        })
    }
}
impl<'db> CSTNode<'db> for ExpressionStatement<'db> {
    fn kind(&self) -> &str {
        &self._kind
    }
    fn start_byte(&self) -> usize {
        self.start_byte
    }
    fn end_byte(&self) -> usize {
        self.end_byte
    }
    fn start_position(&self) -> Point<'db> {
        self.start_position
    }
    fn end_position(&self) -> Point<'db> {
        self.end_position
    }
    fn buffer(&self) -> &Bytes {
        &self.buffer
    }
    fn kind_id(&self) -> u16 {
        self.kind_id
    }
    fn is_error(&self) -> bool {
        self.is_error
    }
    fn is_named(&self) -> bool {
        self.named
    }
    fn id(&self) -> usize {
        self.id
    }
}
impl<'db1> HasChildren<'db1> for ExpressionStatement<'db1> {
    type Child = Self;
    fn children(&self) -> Vec<Self::Child> {
        vec![]
    }
    fn children_by_field_name(&self, field_name: &str) -> Vec<Self::Child> {
        match field_name {
            _ => vec![],
        }
    }
    fn children_by_field_id(&self, field_id: u16) -> Vec<Self::Child> {
        match field_id {
            _ => vec![],
        }
    }
}
impl<'db> std::hash::Hash for ExpressionStatement<'db> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}
#[derive(Debug, Clone, Drive, Eq, PartialEq, salsa::Update)]
pub struct MethodDeclaration<'db> {
    #[drive(skip)]
    start_byte: usize,
    #[drive(skip)]
    end_byte: usize,
    #[drive(skip)]
    _kind: std::string::String,
    #[drive(skip)]
    start_position: Point<'db>,
    #[drive(skip)]
    end_position: Point<'db>,
    #[drive(skip)]
    buffer: Arc<Bytes>,
    #[drive(skip)]
    kind_id: u16,
    #[drive(skip)]
    is_error: bool,
    #[drive(skip)]
    named: bool,
    #[drive(skip)]
    id: usize,
}
impl<'db> FromNode<'db> for MethodDeclaration<'db> {
    fn from_node(
        db: &'db dyn salsa::Database,
        node: tree_sitter::Node,
        buffer: &Arc<Bytes>,
    ) -> Result<Self, ParseError> {
        let start_position = Point::from(db, node.start_position());
        let end_position = Point::from(db, node.end_position());
        Ok(Self {
            start_byte: node.start_byte(),
            end_byte: node.end_byte(),
            _kind: node.kind().to_string(),
            start_position: start_position,
            end_position: end_position,
            buffer: buffer.clone(),
            kind_id: node.kind_id(),
            is_error: node.is_error(),
            named: node.is_named(),
            id: node.id(),
        })
    }
}
impl<'db> CSTNode<'db> for MethodDeclaration<'db> {
    fn kind(&self) -> &str {
        &self._kind
    }
    fn start_byte(&self) -> usize {
        self.start_byte
    }
    fn end_byte(&self) -> usize {
        self.end_byte
    }
    fn start_position(&self) -> Point<'db> {
        self.start_position
    }
    fn end_position(&self) -> Point<'db> {
        self.end_position
    }
    fn buffer(&self) -> &Bytes {
        &self.buffer
    }
    fn kind_id(&self) -> u16 {
        self.kind_id
    }
    fn is_error(&self) -> bool {
        self.is_error
    }
    fn is_named(&self) -> bool {
        self.named
    }
    fn id(&self) -> usize {
        self.id
    }
}
impl<'db1> HasChildren<'db1> for MethodDeclaration<'db1> {
    type Child = Self;
    fn children(&self) -> Vec<Self::Child> {
        vec![]
    }
    fn children_by_field_name(&self, field_name: &str) -> Vec<Self::Child> {
        match field_name {
            _ => vec![],
        }
    }
    fn children_by_field_id(&self, field_id: u16) -> Vec<Self::Child> {
        match field_id {
            _ => vec![],
        }
    }
}
impl<'db> std::hash::Hash for MethodDeclaration<'db> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}
#[salsa::tracked]
pub struct Parsed<'db> {
    #[tracked]
    #[return_ref]
    pub program: Option<Program<'db>>,
}
pub fn parse_program_raw(
    db: &dyn salsa::Database,
    input: codegen_sdk_cst::Input,
) -> Option<Program<'_>> {
    let buffer = Bytes::from(input.content(db).as_bytes().to_vec());
    let tree = codegen_sdk_common::language::language::Language
        .parse_tree_sitter(&input.content(db));
    match tree {
        Ok(tree) => {
            if tree.root_node().has_error() {
                ParseError::SyntaxError.report(db);
                None
            } else {
                let buffer = Arc::new(buffer);
                Program::from_node(db, tree.root_node(), &buffer)
                    .map_or_else(
                        |e| {
                            e.report(db);
                            None
                        },
                        |program| { Some(program) },
                    )
            }
        }
        Err(e) => {
            e.report(db);
            None
        }
    }
}
#[salsa::tracked]
pub fn parse_program(
    db: &dyn salsa::Database,
    input: codegen_sdk_cst::Input,
) -> Parsed<'_> {
    Parsed::new(db, parse_program_raw(db, input))
}
pub struct Language;
impl CSTLanguage for Language {
    type Program<'db> = Program<'db>;
    fn language() -> &'static Language {
        &codegen_sdk_common::language::language::Language
    }
    fn parse<'db>(
        db: &'db dyn salsa::Database,
        content: std::string::String,
    ) -> &'db Option<Self::Program<'db>> {
        let input = codegen_sdk_cst::Input::new(db, content);
        return parse_program(db, input).program(db);
    }
}

---
source: codegen-bindings-generator/src/python/generator.rs
expression: format_code(&output).unwrap()
---
#[pyclass]
pub struct TypescriptFile {
    path: PathBuf,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl TypescriptFile {
    pub fn new(
        path: PathBuf,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { path, codebase }
    }
    fn file<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_typescript::ast::TypescriptFile<'db>> {
        let codebase = self.codebase.get(py);
        if let codegen_sdk_analyzer::ParsedFile::Typescript(file) = codebase
            .get_file(self.path.clone())
            .unwrap()
        {
            Ok(file)
        } else {
            Err(pyo3::exceptions::PyValueError::new_err("File not found"))
        }
    }
}
#[pymethods]
impl TypescriptFile {
    #[getter]
    pub fn content(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let codebase = self.codebase.get(py);
        let file = self.file(py)?.root(codebase.db());
        Ok(file.source())
    }
    #[getter]
    pub fn content_bytes(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
        let codebase = self.codebase.get(py);
        let file = self.file(py)?.root(codebase.db());
        Ok(pyo3_bytes::PyBytes::new(file.text()))
    }
    #[getter]
    pub fn Classes(&self, py: Python<'_>) -> PyResult<Vec<Class>> {
        let file = self.file(py)?;
        let category = file.definition(py)?;
        let subcategory = category.classes(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| Class::new(node.fully_qualified_name(), self.codebase.clone()))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn Functions(&self, py: Python<'_>) -> PyResult<Vec<Function>> {
        let file = self.file(py)?;
        let category = file.definition(py)?;
        let subcategory = category.functions(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| Function::new(
                node.fully_qualified_name(),
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn Interfaces(&self, py: Python<'_>) -> PyResult<Vec<Interface>> {
        let file = self.file(py)?;
        let category = file.definition(py)?;
        let subcategory = category.interfaces(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| Interface::new(
                node.fully_qualified_name(),
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn Methods(&self, py: Python<'_>) -> PyResult<Vec<Method>> {
        let file = self.file(py)?;
        let category = file.definition(py)?;
        let subcategory = category.methods(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| Method::new(node.fully_qualified_name(), self.codebase.clone()))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn Modules(&self, py: Python<'_>) -> PyResult<Vec<Module>> {
        let file = self.file(py)?;
        let category = file.definition(py)?;
        let subcategory = category.modules(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| Module::new(node.fully_qualified_name(), self.codebase.clone()))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn ClassRefs(&self, py: Python<'_>) -> PyResult<Vec<ClassRef>> {
        let file = self.file(py)?;
        let category = file.reference(py)?;
        let subcategory = category.classes(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| ClassRef::new(
                node.fully_qualified_name(),
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn TypeRefs(&self, py: Python<'_>) -> PyResult<Vec<TypeRef>> {
        let file = self.file(py)?;
        let category = file.reference(py)?;
        let subcategory = category.types(py)?;
        let nodes = subcategory
            .iter()
            .map(|node| TypeRef::new(node.fully_qualified_name(), self.codebase.clone()))
            .collect();
        Ok(nodes)
    }
}
mod cst {
    use pyo3::prelude::*;
    use std::sync::Arc;
    use pyo3::sync::GILProtected;
    use codegen_sdk_resolution::CodebaseContext;
    use codegen_sdk_common::traits::CSTNode;
    #[pyclass]
    pub struct AbstractClassDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AbstractClassDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AbstractClassDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AbstractClassDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AbstractMethodSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AbstractMethodSignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AbstractMethodSignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AbstractMethodSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AccessibilityModifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AccessibilityModifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AccessibilityModifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AccessibilityModifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AddingTypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AddingTypeAnnotation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AddingTypeAnnotation<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AddingTypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AmbientDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AmbientDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AmbientDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AmbientDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAbstract {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAbstract {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAbstract<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAbstract {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAccessor {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAccessor {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAccessor<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAccessor {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersand {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersand {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAmpersand<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersand {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersandAmpersand {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandAmpersand {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousAmpersandAmpersand<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandAmpersand {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersandAmpersandEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandAmpersandEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousAmpersandAmpersandEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandAmpersandEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersandEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAmpersandEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAny {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAny {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAny<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAny {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAs {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAs {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAs<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAs {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAssert {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAssert {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAssert<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAssert {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsserts {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsserts {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAsserts<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsserts {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsterisk {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsterisk {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAsterisk<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsterisk {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsteriskAsterisk {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskAsterisk {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAsteriskAsterisk<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskAsterisk {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsteriskAsteriskEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskAsteriskEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousAsteriskAsteriskEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskAsteriskEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsteriskEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAsteriskEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsync {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsync {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAsync<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsync {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAt {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAt {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAt<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAt {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAwait {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAwait {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousAwait<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAwait {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBacktick {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBacktick {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousBacktick<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBacktick {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBang {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBang {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousBang<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBang {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBangEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBangEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousBangEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBangEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBangEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBangEqualsEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousBangEqualsEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBangEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBoolean {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBoolean {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousBoolean<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBoolean {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBreak {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBreak {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousBreak<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBreak {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCaret {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCaret {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCaret<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCaret {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCaretEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCaretEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCaretEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCaretEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCase {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCase {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCase<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCase {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCatch {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCatch {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCatch<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCatch {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousClass {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousClass {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousClass<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousClass {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCloseBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseBrace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCloseBrace<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCloseBracket {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseBracket {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCloseBracket<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseBracket {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCloseParen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseParen {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousCloseParen<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseParen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousColon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousColon<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousComma {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousComma {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousComma<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousComma {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousConst {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousConst {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousConst<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousConst {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousContinue {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousContinue {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousContinue<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousContinue {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDebugger {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDebugger {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDebugger<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDebugger {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDeclare {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDeclare {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDeclare<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDeclare {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDefault {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDefault {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDefault<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDefault {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDelete {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDelete {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDelete<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDelete {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDo {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDo {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDo<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDo {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDollarOpenBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDollarOpenBrace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDollarOpenBrace<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDollarOpenBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDot {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDot<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDotDotDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDotDotDot {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDotDotDot<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDotDotDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDoubleQuote {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDoubleQuote {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousDoubleQuote<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDoubleQuote {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousElse {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousElse {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousElse<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousElse {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEnum {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEnum {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousEnum<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEnum {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousEqualsEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEqualsEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsEqualsEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousEqualsEqualsEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEqualsGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousEqualsGreaterThan<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousExport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousExport {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousExport<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousExport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousExtends {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousExtends {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousExtends<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousExtends {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFinally {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFinally {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousFinally<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFinally {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFor {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFor {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousFor<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFor {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFrom {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFrom {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousFrom<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFrom {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFunction {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousFunction<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGet {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousGet<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGlobal {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGlobal {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousGlobal<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGlobal {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousGreaterThan<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousGreaterThanEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThan<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThanEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanGreaterThanGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThanGreaterThan<
                'db,
            >,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanGreaterThanGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanGreaterThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThanGreaterThanEquals<
                'db,
            >,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousIf {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIf {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousIf<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIf {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousImplements {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousImplements {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousImplements<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousImplements {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousImport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousImport {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousImport<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousImport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousIn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIn {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousIn<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousInfer {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousInfer {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousInfer<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousInfer {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousInstanceof {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousInstanceof {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousInstanceof<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousInstanceof {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousInterface {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousInterface {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousInterface<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousInterface {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousIs {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIs {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousIs<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIs {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousKeyof {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousKeyof {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousKeyof<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousKeyof {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousLessThan<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousLessThanEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThanLessThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanLessThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousLessThanLessThan<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanLessThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThanLessThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanLessThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousLessThanLessThanEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanLessThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLet {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousLet<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMeta {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMeta {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousMeta<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMeta {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinus {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousMinus<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinusEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousMinusEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinusMinus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusMinus {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousMinusMinus<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusMinus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinusQuestionMarkColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusQuestionMarkColon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousMinusQuestionMarkColon<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusQuestionMarkColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousModule {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousModule {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousModule<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousModule {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousNamespace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNamespace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousNamespace<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNamespace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousNever {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNever {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousNever<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNever {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousNew {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNew {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousNew<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNew {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousNumber {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNumber {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousNumber<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNumber {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousObject {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousObject {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousObject<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousObject {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOf {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOf {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousOf<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOf {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBrace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousOpenBrace<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenBracePipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBracePipe {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousOpenBracePipe<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBracePipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenBracket {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBracket {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousOpenBracket<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBracket {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenParen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenParen {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousOpenParen<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenParen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOverride {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOverride {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousOverride<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOverride {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPercent {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPercent {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPercent<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPercent {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPercentEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPercentEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPercentEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPercentEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipe {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPipe<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipeCloseBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipeCloseBrace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPipeCloseBrace<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipeCloseBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipeEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipeEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPipeEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipeEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipePipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipePipe {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPipePipe<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipePipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipePipeEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipePipeEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPipePipeEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipePipeEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPlus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlus {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPlus<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPlusEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPlusEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPlusPlus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusPlus {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPlusPlus<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusPlus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPlusQuestionMarkColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusQuestionMarkColon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousPlusQuestionMarkColon<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusQuestionMarkColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPrivate {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPrivate {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPrivate<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPrivate {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousProtected {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousProtected {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousProtected<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousProtected {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPublic {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPublic {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousPublic<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPublic {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousQuestionMark {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMark {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousQuestionMark<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMark {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousQuestionMarkColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkColon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousQuestionMarkColon<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousQuestionMarkDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkDot {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousQuestionMarkDot<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousQuestionMarkQuestionMark {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkQuestionMark {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousQuestionMarkQuestionMark<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkQuestionMark {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousQuestionMarkQuestionMarkEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkQuestionMarkEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AnonymousQuestionMarkQuestionMarkEquals<
                'db,
            >,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkQuestionMarkEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousReadonly {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousReadonly {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousReadonly<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousReadonly {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousRequire {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousRequire {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousRequire<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousRequire {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousReturn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousReturn {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousReturn<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousReturn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSatisfies {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSatisfies {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSatisfies<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSatisfies {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSemicolon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSemicolon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSemicolon<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSemicolon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSet {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSet<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSingleQuote {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSingleQuote {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSingleQuote<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSingleQuote {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSlash {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlash {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSlash<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlash {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSlashEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlashEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSlashEquals<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlashEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousStatic {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousStatic {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousStatic<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousStatic {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousString {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousString {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousString<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousString {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSwitch {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSwitch {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSwitch<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSwitch {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSymbol {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSymbol {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousSymbol<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSymbol {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTarget {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTarget {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousTarget<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTarget {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousThrow {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousThrow {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousThrow<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousThrow {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTilde {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTilde {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousTilde<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTilde {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTry {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTry {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousTry<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTry {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTypeof {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTypeof {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousTypeof<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTypeof {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUniqueSymbol {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUniqueSymbol {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousUniqueSymbol<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUniqueSymbol {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUnknown {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUnknown {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousUnknown<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUnknown {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUsing {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUsing {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousUsing<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUsing {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousVar {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousVar {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousVar<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousVar {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousVoid {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousVoid {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousVoid<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousVoid {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousWhile {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousWhile {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousWhile<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousWhile {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousWith {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousWith {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousWith<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousWith {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousYield {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousYield {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AnonymousYield<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousYield {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Arguments {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Arguments {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Arguments<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Arguments {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Array {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Array {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Array<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Array {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ArrayPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrayPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ArrayPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ArrayPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ArrayType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrayType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ArrayType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ArrayType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ArrowFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrowFunction {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ArrowFunction<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ArrowFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AsExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AsExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AsExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AsExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Asserts {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Asserts {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Asserts<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Asserts {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AssertsAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssertsAnnotation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AssertsAnnotation<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AssertsAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AssignmentExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssignmentExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AssignmentExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AssignmentExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AssignmentPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssignmentPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AssignmentPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AssignmentPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AugmentedAssignmentExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AugmentedAssignmentExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::AugmentedAssignmentExpression<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AugmentedAssignmentExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AwaitExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AwaitExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::AwaitExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl AwaitExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BinaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BinaryExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::BinaryExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl BinaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BreakStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BreakStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::BreakStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl BreakStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CallExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CallExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::CallExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl CallExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CallSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CallSignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::CallSignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl CallSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CatchClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CatchClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::CatchClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl CatchClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Class {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Class {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Class<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Class {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ClassBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassBody {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ClassBody<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ClassBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ClassDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ClassDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ClassDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ClassHeritage {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassHeritage {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ClassHeritage<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ClassHeritage {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ClassStaticBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassStaticBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ClassStaticBlock<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ClassStaticBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Comment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Comment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Comment<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Comment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ComputedPropertyName {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ComputedPropertyName {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ComputedPropertyName<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ComputedPropertyName {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConditionalType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConditionalType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ConditionalType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ConditionalType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Constraint {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Constraint {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Constraint<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Constraint {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConstructSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstructSignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ConstructSignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ConstructSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConstructorType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstructorType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ConstructorType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ConstructorType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ContinueStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ContinueStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ContinueStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ContinueStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct DebuggerStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DebuggerStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::DebuggerStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl DebuggerStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Decorator {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Decorator {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Decorator<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Decorator {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct DefaultType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DefaultType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::DefaultType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl DefaultType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct DoStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DoStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::DoStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl DoStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ElseClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ElseClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ElseClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ElseClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EmptyStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EmptyStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::EmptyStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl EmptyStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EnumAssignment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumAssignment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::EnumAssignment<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl EnumAssignment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EnumBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumBody {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::EnumBody<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl EnumBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EnumDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::EnumDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl EnumDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EscapeSequence {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EscapeSequence {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::EscapeSequence<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl EscapeSequence {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExistentialType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExistentialType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExistentialType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExistentialType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExportClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExportClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExportClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExportClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExportSpecifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExportSpecifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExportSpecifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExportSpecifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExportStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExportStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExportStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExportStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExpressionStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExpressionStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExpressionStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExpressionStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExtendsClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExtendsClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExtendsClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExtendsClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExtendsTypeClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExtendsTypeClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ExtendsTypeClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ExtendsTypeClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct False {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl False {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::False<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl False {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FinallyClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FinallyClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FinallyClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FinallyClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FlowMaybeType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FlowMaybeType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FlowMaybeType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FlowMaybeType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ForInStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForInStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ForInStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ForInStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ForStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ForStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ForStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FormalParameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FormalParameters {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FormalParameters<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FormalParameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FunctionDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FunctionExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionSignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FunctionSignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::FunctionType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GeneratorFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GeneratorFunction {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::GeneratorFunction<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl GeneratorFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GeneratorFunctionDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GeneratorFunctionDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::GeneratorFunctionDeclaration<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl GeneratorFunctionDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GenericType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GenericType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::GenericType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl GenericType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct HashBangLine {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl HashBangLine {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::HashBangLine<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl HashBangLine {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct HtmlComment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl HtmlComment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::HtmlComment<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl HtmlComment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Identifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Identifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Identifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Identifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IfStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IfStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::IfStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl IfStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImplementsClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImplementsClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImplementsClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImplementsClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Import {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Import {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Import<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Import {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImportAlias {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportAlias {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImportAlias<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImportAlias {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImportAttribute {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportAttribute {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImportAttribute<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImportAttribute {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImportClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImportClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImportClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImportRequireClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportRequireClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImportRequireClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImportRequireClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImportSpecifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportSpecifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImportSpecifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImportSpecifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImportStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ImportStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ImportStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IndexSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IndexSignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::IndexSignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl IndexSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IndexTypeQuery {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IndexTypeQuery {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::IndexTypeQuery<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl IndexTypeQuery {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InferType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InferType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::InferType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl InferType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InstantiationExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InstantiationExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::InstantiationExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl InstantiationExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InterfaceBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InterfaceBody {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::InterfaceBody<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl InterfaceBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InterfaceDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InterfaceDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::InterfaceDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl InterfaceDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InternalModule {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InternalModule {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::InternalModule<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl InternalModule {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IntersectionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IntersectionType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::IntersectionType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl IntersectionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LabeledStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LabeledStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::LabeledStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl LabeledStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LexicalDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LexicalDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::LexicalDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl LexicalDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LiteralType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LiteralType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::LiteralType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl LiteralType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LookupType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LookupType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::LookupType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl LookupType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MappedTypeClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MappedTypeClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::MappedTypeClause<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl MappedTypeClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MemberExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MemberExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::MemberExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl MemberExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MetaProperty {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MetaProperty {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::MetaProperty<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl MetaProperty {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MethodDefinition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MethodDefinition {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::MethodDefinition<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl MethodDefinition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MethodSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MethodSignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::MethodSignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl MethodSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Module {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Module {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Module<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Module {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NamedImports {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NamedImports {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NamedImports<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NamedImports {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NamespaceExport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NamespaceExport {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NamespaceExport<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NamespaceExport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NamespaceImport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NamespaceImport {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NamespaceImport<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NamespaceImport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NestedIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NestedIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NestedIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NestedIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NestedTypeIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NestedTypeIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NestedTypeIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NestedTypeIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NewExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NewExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NewExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NewExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NonNullExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NonNullExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::NonNullExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl NonNullExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Null {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Null {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Null<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Null {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Number {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Number {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Number<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Number {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Object {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Object {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Object<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Object {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ObjectAssignmentPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ObjectAssignmentPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ObjectAssignmentPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ObjectAssignmentPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ObjectPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ObjectPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ObjectPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ObjectPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ObjectType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ObjectType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ObjectType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ObjectType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OmittingTypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OmittingTypeAnnotation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::OmittingTypeAnnotation<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl OmittingTypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OptingTypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptingTypeAnnotation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::OptingTypeAnnotation<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl OptingTypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OptionalChain {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalChain {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::OptionalChain<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalChain {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OptionalParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::OptionalParameter<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OptionalType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::OptionalType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OverrideModifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OverrideModifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::OverrideModifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl OverrideModifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Pair {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Pair {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Pair<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Pair {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PairPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PairPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::PairPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl PairPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ParenthesizedExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ParenthesizedExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ParenthesizedExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ParenthesizedExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ParenthesizedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ParenthesizedType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ParenthesizedType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ParenthesizedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PredefinedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PredefinedType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::PredefinedType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl PredefinedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PrivatePropertyIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PrivatePropertyIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::PrivatePropertyIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl PrivatePropertyIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Program {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Program {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Program<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Program {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PropertyIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PropertyIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::PropertyIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl PropertyIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PropertySignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PropertySignature {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::PropertySignature<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl PropertySignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PublicFieldDefinition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PublicFieldDefinition {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::PublicFieldDefinition<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl PublicFieldDefinition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ReadonlyType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReadonlyType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ReadonlyType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ReadonlyType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Regex {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Regex {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Regex<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Regex {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RegexFlags {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RegexFlags {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::RegexFlags<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl RegexFlags {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RegexPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RegexPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::RegexPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl RegexPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RequiredParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RequiredParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::RequiredParameter<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl RequiredParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RestPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RestPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::RestPattern<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl RestPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RestType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RestType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::RestType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl RestType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ReturnStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReturnStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ReturnStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ReturnStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SatisfiesExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SatisfiesExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SatisfiesExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SatisfiesExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SequenceExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SequenceExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SequenceExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SequenceExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ShorthandPropertyIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ShorthandPropertyIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::ShorthandPropertyIdentifier<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ShorthandPropertyIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ShorthandPropertyIdentifierPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ShorthandPropertyIdentifierPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_typescript::cst::ShorthandPropertyIdentifierPattern<'db>,
        > {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ShorthandPropertyIdentifierPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SpreadElement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SpreadElement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SpreadElement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SpreadElement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StatementBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StatementBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::StatementBlock<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl StatementBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StatementIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StatementIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::StatementIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl StatementIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct String {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl String {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::String<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl String {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StringFragment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StringFragment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::StringFragment<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl StringFragment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SubscriptExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SubscriptExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SubscriptExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SubscriptExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Super {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Super {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Super<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Super {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SwitchBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchBody {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SwitchBody<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SwitchCase {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchCase {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SwitchCase<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchCase {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SwitchDefault {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchDefault {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SwitchDefault<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchDefault {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SwitchStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::SwitchStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TemplateLiteralType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateLiteralType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TemplateLiteralType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateLiteralType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TemplateString {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateString {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TemplateString<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateString {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TemplateSubstitution {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateSubstitution {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TemplateSubstitution<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateSubstitution {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TemplateType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TemplateType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TernaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TernaryExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TernaryExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TernaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct This {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl This {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::This<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl This {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ThisType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ThisType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ThisType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ThisType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ThrowStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ThrowStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::ThrowStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl ThrowStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct True {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl True {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::True<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl True {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TryStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TryStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TryStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TryStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TupleType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TupleType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TupleType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TupleType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeAliasDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeAliasDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeAliasDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeAliasDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeAnnotation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeAnnotation<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeArguments {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeArguments {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeArguments<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeArguments {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeAssertion {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeAssertion {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeAssertion<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeAssertion {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeParameter<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeParameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeParameters {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeParameters<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeParameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypePredicate {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypePredicate {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypePredicate<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypePredicate {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypePredicateAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypePredicateAnnotation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypePredicateAnnotation<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypePredicateAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeQuery {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeQuery {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::TypeQuery<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl TypeQuery {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnaryExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::UnaryExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl UnaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Undefined {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Undefined {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::Undefined<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl Undefined {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnionType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::UnionType<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl UnionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UpdateExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UpdateExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::UpdateExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl UpdateExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct VariableDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl VariableDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::VariableDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl VariableDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct VariableDeclarator {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl VariableDeclarator {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::VariableDeclarator<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl VariableDeclarator {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct WhileStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WhileStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::WhileStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl WhileStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct WithStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WithStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::WithStatement<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl WithStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct YieldExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl YieldExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_typescript::cst::YieldExpression<'db>> {
            let codebase = self.codebase.get(py);
            let file = codebase.get_file_for_id(self.id.file(codebase.db()));
            if let Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) = file {
                let tree = py.tree(codebase.db());
                let node = tree.get(self.id.id(codebase.db()));
                if let Some(node) = node {
                    node.as_ref()
                        .try_into()
                        .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                            format!("Failed to convert node to CSTNode {}", e),
                        ))
                } else {
                    Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("File not found"))
            }
        }
    }
    #[pymethods]
    impl YieldExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    pub fn register_cst(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
        let child_module = PyModule::new(parent_module.py(), "cst")?;
        child_module.add_class::<AbstractClassDeclaration>()?;
        child_module.add_class::<AbstractMethodSignature>()?;
        child_module.add_class::<AccessibilityModifier>()?;
        child_module.add_class::<AddingTypeAnnotation>()?;
        child_module.add_class::<AmbientDeclaration>()?;
        child_module.add_class::<AnonymousAbstract>()?;
        child_module.add_class::<AnonymousAccessor>()?;
        child_module.add_class::<AnonymousAmpersand>()?;
        child_module.add_class::<AnonymousAmpersandAmpersand>()?;
        child_module.add_class::<AnonymousAmpersandAmpersandEquals>()?;
        child_module.add_class::<AnonymousAmpersandEquals>()?;
        child_module.add_class::<AnonymousAny>()?;
        child_module.add_class::<AnonymousAs>()?;
        child_module.add_class::<AnonymousAssert>()?;
        child_module.add_class::<AnonymousAsserts>()?;
        child_module.add_class::<AnonymousAsterisk>()?;
        child_module.add_class::<AnonymousAsteriskAsterisk>()?;
        child_module.add_class::<AnonymousAsteriskAsteriskEquals>()?;
        child_module.add_class::<AnonymousAsteriskEquals>()?;
        child_module.add_class::<AnonymousAsync>()?;
        child_module.add_class::<AnonymousAt>()?;
        child_module.add_class::<AnonymousAwait>()?;
        child_module.add_class::<AnonymousBacktick>()?;
        child_module.add_class::<AnonymousBang>()?;
        child_module.add_class::<AnonymousBangEquals>()?;
        child_module.add_class::<AnonymousBangEqualsEquals>()?;
        child_module.add_class::<AnonymousBoolean>()?;
        child_module.add_class::<AnonymousBreak>()?;
        child_module.add_class::<AnonymousCaret>()?;
        child_module.add_class::<AnonymousCaretEquals>()?;
        child_module.add_class::<AnonymousCase>()?;
        child_module.add_class::<AnonymousCatch>()?;
        child_module.add_class::<AnonymousClass>()?;
        child_module.add_class::<AnonymousCloseBrace>()?;
        child_module.add_class::<AnonymousCloseBracket>()?;
        child_module.add_class::<AnonymousCloseParen>()?;
        child_module.add_class::<AnonymousColon>()?;
        child_module.add_class::<AnonymousComma>()?;
        child_module.add_class::<AnonymousConst>()?;
        child_module.add_class::<AnonymousContinue>()?;
        child_module.add_class::<AnonymousDebugger>()?;
        child_module.add_class::<AnonymousDeclare>()?;
        child_module.add_class::<AnonymousDefault>()?;
        child_module.add_class::<AnonymousDelete>()?;
        child_module.add_class::<AnonymousDo>()?;
        child_module.add_class::<AnonymousDollarOpenBrace>()?;
        child_module.add_class::<AnonymousDot>()?;
        child_module.add_class::<AnonymousDotDotDot>()?;
        child_module.add_class::<AnonymousDoubleQuote>()?;
        child_module.add_class::<AnonymousElse>()?;
        child_module.add_class::<AnonymousEnum>()?;
        child_module.add_class::<AnonymousEquals>()?;
        child_module.add_class::<AnonymousEqualsEquals>()?;
        child_module.add_class::<AnonymousEqualsEqualsEquals>()?;
        child_module.add_class::<AnonymousEqualsGreaterThan>()?;
        child_module.add_class::<AnonymousExport>()?;
        child_module.add_class::<AnonymousExtends>()?;
        child_module.add_class::<AnonymousFinally>()?;
        child_module.add_class::<AnonymousFor>()?;
        child_module.add_class::<AnonymousFrom>()?;
        child_module.add_class::<AnonymousFunction>()?;
        child_module.add_class::<AnonymousGet>()?;
        child_module.add_class::<AnonymousGlobal>()?;
        child_module.add_class::<AnonymousGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanEquals>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanEquals>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanGreaterThanEquals>()?;
        child_module.add_class::<AnonymousIf>()?;
        child_module.add_class::<AnonymousImplements>()?;
        child_module.add_class::<AnonymousImport>()?;
        child_module.add_class::<AnonymousIn>()?;
        child_module.add_class::<AnonymousInfer>()?;
        child_module.add_class::<AnonymousInstanceof>()?;
        child_module.add_class::<AnonymousInterface>()?;
        child_module.add_class::<AnonymousIs>()?;
        child_module.add_class::<AnonymousKeyof>()?;
        child_module.add_class::<AnonymousLessThan>()?;
        child_module.add_class::<AnonymousLessThanEquals>()?;
        child_module.add_class::<AnonymousLessThanLessThan>()?;
        child_module.add_class::<AnonymousLessThanLessThanEquals>()?;
        child_module.add_class::<AnonymousLet>()?;
        child_module.add_class::<AnonymousMeta>()?;
        child_module.add_class::<AnonymousMinus>()?;
        child_module.add_class::<AnonymousMinusEquals>()?;
        child_module.add_class::<AnonymousMinusMinus>()?;
        child_module.add_class::<AnonymousMinusQuestionMarkColon>()?;
        child_module.add_class::<AnonymousModule>()?;
        child_module.add_class::<AnonymousNamespace>()?;
        child_module.add_class::<AnonymousNever>()?;
        child_module.add_class::<AnonymousNew>()?;
        child_module.add_class::<AnonymousNumber>()?;
        child_module.add_class::<AnonymousObject>()?;
        child_module.add_class::<AnonymousOf>()?;
        child_module.add_class::<AnonymousOpenBrace>()?;
        child_module.add_class::<AnonymousOpenBracePipe>()?;
        child_module.add_class::<AnonymousOpenBracket>()?;
        child_module.add_class::<AnonymousOpenParen>()?;
        child_module.add_class::<AnonymousOverride>()?;
        child_module.add_class::<AnonymousPercent>()?;
        child_module.add_class::<AnonymousPercentEquals>()?;
        child_module.add_class::<AnonymousPipe>()?;
        child_module.add_class::<AnonymousPipeCloseBrace>()?;
        child_module.add_class::<AnonymousPipeEquals>()?;
        child_module.add_class::<AnonymousPipePipe>()?;
        child_module.add_class::<AnonymousPipePipeEquals>()?;
        child_module.add_class::<AnonymousPlus>()?;
        child_module.add_class::<AnonymousPlusEquals>()?;
        child_module.add_class::<AnonymousPlusPlus>()?;
        child_module.add_class::<AnonymousPlusQuestionMarkColon>()?;
        child_module.add_class::<AnonymousPrivate>()?;
        child_module.add_class::<AnonymousProtected>()?;
        child_module.add_class::<AnonymousPublic>()?;
        child_module.add_class::<AnonymousQuestionMark>()?;
        child_module.add_class::<AnonymousQuestionMarkColon>()?;
        child_module.add_class::<AnonymousQuestionMarkDot>()?;
        child_module.add_class::<AnonymousQuestionMarkQuestionMark>()?;
        child_module.add_class::<AnonymousQuestionMarkQuestionMarkEquals>()?;
        child_module.add_class::<AnonymousReadonly>()?;
        child_module.add_class::<AnonymousRequire>()?;
        child_module.add_class::<AnonymousReturn>()?;
        child_module.add_class::<AnonymousSatisfies>()?;
        child_module.add_class::<AnonymousSemicolon>()?;
        child_module.add_class::<AnonymousSet>()?;
        child_module.add_class::<AnonymousSingleQuote>()?;
        child_module.add_class::<AnonymousSlash>()?;
        child_module.add_class::<AnonymousSlashEquals>()?;
        child_module.add_class::<AnonymousStatic>()?;
        child_module.add_class::<AnonymousString>()?;
        child_module.add_class::<AnonymousSwitch>()?;
        child_module.add_class::<AnonymousSymbol>()?;
        child_module.add_class::<AnonymousTarget>()?;
        child_module.add_class::<AnonymousThrow>()?;
        child_module.add_class::<AnonymousTilde>()?;
        child_module.add_class::<AnonymousTry>()?;
        child_module.add_class::<AnonymousType>()?;
        child_module.add_class::<AnonymousTypeof>()?;
        child_module.add_class::<AnonymousUniqueSymbol>()?;
        child_module.add_class::<AnonymousUnknown>()?;
        child_module.add_class::<AnonymousUsing>()?;
        child_module.add_class::<AnonymousVar>()?;
        child_module.add_class::<AnonymousVoid>()?;
        child_module.add_class::<AnonymousWhile>()?;
        child_module.add_class::<AnonymousWith>()?;
        child_module.add_class::<AnonymousYield>()?;
        child_module.add_class::<Arguments>()?;
        child_module.add_class::<Array>()?;
        child_module.add_class::<ArrayPattern>()?;
        child_module.add_class::<ArrayType>()?;
        child_module.add_class::<ArrowFunction>()?;
        child_module.add_class::<AsExpression>()?;
        child_module.add_class::<Asserts>()?;
        child_module.add_class::<AssertsAnnotation>()?;
        child_module.add_class::<AssignmentExpression>()?;
        child_module.add_class::<AssignmentPattern>()?;
        child_module.add_class::<AugmentedAssignmentExpression>()?;
        child_module.add_class::<AwaitExpression>()?;
        child_module.add_class::<BinaryExpression>()?;
        child_module.add_class::<BreakStatement>()?;
        child_module.add_class::<CallExpression>()?;
        child_module.add_class::<CallSignature>()?;
        child_module.add_class::<CatchClause>()?;
        child_module.add_class::<Class>()?;
        child_module.add_class::<ClassBody>()?;
        child_module.add_class::<ClassDeclaration>()?;
        child_module.add_class::<ClassHeritage>()?;
        child_module.add_class::<ClassStaticBlock>()?;
        child_module.add_class::<Comment>()?;
        child_module.add_class::<ComputedPropertyName>()?;
        child_module.add_class::<ConditionalType>()?;
        child_module.add_class::<Constraint>()?;
        child_module.add_class::<ConstructSignature>()?;
        child_module.add_class::<ConstructorType>()?;
        child_module.add_class::<ContinueStatement>()?;
        child_module.add_class::<DebuggerStatement>()?;
        child_module.add_class::<Decorator>()?;
        child_module.add_class::<DefaultType>()?;
        child_module.add_class::<DoStatement>()?;
        child_module.add_class::<ElseClause>()?;
        child_module.add_class::<EmptyStatement>()?;
        child_module.add_class::<EnumAssignment>()?;
        child_module.add_class::<EnumBody>()?;
        child_module.add_class::<EnumDeclaration>()?;
        child_module.add_class::<EscapeSequence>()?;
        child_module.add_class::<ExistentialType>()?;
        child_module.add_class::<ExportClause>()?;
        child_module.add_class::<ExportSpecifier>()?;
        child_module.add_class::<ExportStatement>()?;
        child_module.add_class::<ExpressionStatement>()?;
        child_module.add_class::<ExtendsClause>()?;
        child_module.add_class::<ExtendsTypeClause>()?;
        child_module.add_class::<False>()?;
        child_module.add_class::<FinallyClause>()?;
        child_module.add_class::<FlowMaybeType>()?;
        child_module.add_class::<ForInStatement>()?;
        child_module.add_class::<ForStatement>()?;
        child_module.add_class::<FormalParameters>()?;
        child_module.add_class::<FunctionDeclaration>()?;
        child_module.add_class::<FunctionExpression>()?;
        child_module.add_class::<FunctionSignature>()?;
        child_module.add_class::<FunctionType>()?;
        child_module.add_class::<GeneratorFunction>()?;
        child_module.add_class::<GeneratorFunctionDeclaration>()?;
        child_module.add_class::<GenericType>()?;
        child_module.add_class::<HashBangLine>()?;
        child_module.add_class::<HtmlComment>()?;
        child_module.add_class::<Identifier>()?;
        child_module.add_class::<IfStatement>()?;
        child_module.add_class::<ImplementsClause>()?;
        child_module.add_class::<Import>()?;
        child_module.add_class::<ImportAlias>()?;
        child_module.add_class::<ImportAttribute>()?;
        child_module.add_class::<ImportClause>()?;
        child_module.add_class::<ImportRequireClause>()?;
        child_module.add_class::<ImportSpecifier>()?;
        child_module.add_class::<ImportStatement>()?;
        child_module.add_class::<IndexSignature>()?;
        child_module.add_class::<IndexTypeQuery>()?;
        child_module.add_class::<InferType>()?;
        child_module.add_class::<InstantiationExpression>()?;
        child_module.add_class::<InterfaceBody>()?;
        child_module.add_class::<InterfaceDeclaration>()?;
        child_module.add_class::<InternalModule>()?;
        child_module.add_class::<IntersectionType>()?;
        child_module.add_class::<LabeledStatement>()?;
        child_module.add_class::<LexicalDeclaration>()?;
        child_module.add_class::<LiteralType>()?;
        child_module.add_class::<LookupType>()?;
        child_module.add_class::<MappedTypeClause>()?;
        child_module.add_class::<MemberExpression>()?;
        child_module.add_class::<MetaProperty>()?;
        child_module.add_class::<MethodDefinition>()?;
        child_module.add_class::<MethodSignature>()?;
        child_module.add_class::<Module>()?;
        child_module.add_class::<NamedImports>()?;
        child_module.add_class::<NamespaceExport>()?;
        child_module.add_class::<NamespaceImport>()?;
        child_module.add_class::<NestedIdentifier>()?;
        child_module.add_class::<NestedTypeIdentifier>()?;
        child_module.add_class::<NewExpression>()?;
        child_module.add_class::<NonNullExpression>()?;
        child_module.add_class::<Null>()?;
        child_module.add_class::<Number>()?;
        child_module.add_class::<Object>()?;
        child_module.add_class::<ObjectAssignmentPattern>()?;
        child_module.add_class::<ObjectPattern>()?;
        child_module.add_class::<ObjectType>()?;
        child_module.add_class::<OmittingTypeAnnotation>()?;
        child_module.add_class::<OptingTypeAnnotation>()?;
        child_module.add_class::<OptionalChain>()?;
        child_module.add_class::<OptionalParameter>()?;
        child_module.add_class::<OptionalType>()?;
        child_module.add_class::<OverrideModifier>()?;
        child_module.add_class::<Pair>()?;
        child_module.add_class::<PairPattern>()?;
        child_module.add_class::<ParenthesizedExpression>()?;
        child_module.add_class::<ParenthesizedType>()?;
        child_module.add_class::<PredefinedType>()?;
        child_module.add_class::<PrivatePropertyIdentifier>()?;
        child_module.add_class::<Program>()?;
        child_module.add_class::<PropertyIdentifier>()?;
        child_module.add_class::<PropertySignature>()?;
        child_module.add_class::<PublicFieldDefinition>()?;
        child_module.add_class::<ReadonlyType>()?;
        child_module.add_class::<Regex>()?;
        child_module.add_class::<RegexFlags>()?;
        child_module.add_class::<RegexPattern>()?;
        child_module.add_class::<RequiredParameter>()?;
        child_module.add_class::<RestPattern>()?;
        child_module.add_class::<RestType>()?;
        child_module.add_class::<ReturnStatement>()?;
        child_module.add_class::<SatisfiesExpression>()?;
        child_module.add_class::<SequenceExpression>()?;
        child_module.add_class::<ShorthandPropertyIdentifier>()?;
        child_module.add_class::<ShorthandPropertyIdentifierPattern>()?;
        child_module.add_class::<SpreadElement>()?;
        child_module.add_class::<StatementBlock>()?;
        child_module.add_class::<StatementIdentifier>()?;
        child_module.add_class::<String>()?;
        child_module.add_class::<StringFragment>()?;
        child_module.add_class::<SubscriptExpression>()?;
        child_module.add_class::<Super>()?;
        child_module.add_class::<SwitchBody>()?;
        child_module.add_class::<SwitchCase>()?;
        child_module.add_class::<SwitchDefault>()?;
        child_module.add_class::<SwitchStatement>()?;
        child_module.add_class::<TemplateLiteralType>()?;
        child_module.add_class::<TemplateString>()?;
        child_module.add_class::<TemplateSubstitution>()?;
        child_module.add_class::<TemplateType>()?;
        child_module.add_class::<TernaryExpression>()?;
        child_module.add_class::<This>()?;
        child_module.add_class::<ThisType>()?;
        child_module.add_class::<ThrowStatement>()?;
        child_module.add_class::<True>()?;
        child_module.add_class::<TryStatement>()?;
        child_module.add_class::<TupleType>()?;
        child_module.add_class::<TypeAliasDeclaration>()?;
        child_module.add_class::<TypeAnnotation>()?;
        child_module.add_class::<TypeArguments>()?;
        child_module.add_class::<TypeAssertion>()?;
        child_module.add_class::<TypeIdentifier>()?;
        child_module.add_class::<TypeParameter>()?;
        child_module.add_class::<TypeParameters>()?;
        child_module.add_class::<TypePredicate>()?;
        child_module.add_class::<TypePredicateAnnotation>()?;
        child_module.add_class::<TypeQuery>()?;
        child_module.add_class::<UnaryExpression>()?;
        child_module.add_class::<Undefined>()?;
        child_module.add_class::<UnionType>()?;
        child_module.add_class::<UpdateExpression>()?;
        child_module.add_class::<VariableDeclaration>()?;
        child_module.add_class::<VariableDeclarator>()?;
        child_module.add_class::<WhileStatement>()?;
        child_module.add_class::<WithStatement>()?;
        child_module.add_class::<YieldExpression>()?;
        parent_module.add_submodule(&child_module)?;
        Ok(())
    }
}
#[pyclass]
pub struct Class {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Class {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
#[pyclass]
pub struct Function {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Function {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
#[pyclass]
pub struct Interface {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Interface {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
#[pyclass]
pub struct Method {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Method {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
#[pyclass]
pub struct Module {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Module {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
#[pyclass]
pub struct ClassRef {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl ClassRef {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
#[pyclass]
pub struct TypeRef {
    id: codegen_sdk_resolution::FullyQualifiedName,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl TypeRef {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, codebase }
    }
}
pub fn register_typescript(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let child_module = PyModule::new(parent_module.py(), "typescript")?;
    child_module.add_class::<TypescriptFile>()?;
    child_module.add_class::<Class>()?;
    child_module.add_class::<Function>()?;
    child_module.add_class::<Interface>()?;
    child_module.add_class::<Method>()?;
    child_module.add_class::<Module>()?;
    child_module.add_class::<ClassRef>()?;
    child_module.add_class::<TypeRef>()?;
    parent_module.add_submodule(&child_module)?;
    cst::register_cst(&child_module)?;
    Ok(())
}

---
source: codegen-bindings-generator/src/python/generator.rs
expression: format_code(&output).unwrap()
---
#[pyclass]
pub struct RustFile {
    path: PathBuf,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl RustFile {
    pub fn new(
        path: PathBuf,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { path, codebase }
    }
    fn file<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::RustFile<'db>> {
        let codebase = self.codebase.get(py);
        if let codegen_sdk_analyzer::ParsedFile::Rust(file) = codebase
            .get_file(&self.path)
            .unwrap()
        {
            Ok(file)
        } else {
            Err(pyo3::exceptions::PyValueError::new_err("File not found"))
        }
    }
}
#[pymethods]
impl RustFile {
    #[getter]
    pub fn path(&self) -> &PathBuf {
        &self.path
    }
    #[getter]
    pub fn content(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let codebase = self.codebase.get(py);
        let file = self.file(py)?.root(codebase.db());
        Ok(file.source())
    }
    #[getter]
    pub fn content_bytes(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
        let codebase = self.codebase.get(py);
        let file = self.file(py)?.root(codebase.db());
        Ok(pyo3_bytes::PyBytes::new(file.text()))
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.content(py)?.to_string())
    }
    #[getter]
    pub fn classes(&self, py: Python<'_>) -> PyResult<Vec<Class>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.classes(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Class::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn functions(&self, py: Python<'_>) -> PyResult<Vec<Function>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.functions(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Function::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn interfaces(&self, py: Python<'_>) -> PyResult<Vec<Interface>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.interfaces(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Interface::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn macros(&self, py: Python<'_>) -> PyResult<Vec<Macro>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.macros(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Macro::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn methods(&self, py: Python<'_>) -> PyResult<Vec<Method>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.methods(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Method::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn modules(&self, py: Python<'_>) -> PyResult<Vec<Module>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.modules(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Module::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn calls(&self, py: Python<'_>) -> PyResult<Vec<Call>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.references(db);
        let subcategory = category.calls(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| Call::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
    #[getter]
    pub fn implementation_refs(
        &self,
        py: Python<'_>,
    ) -> PyResult<Vec<ImplementationRef>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.references(db);
        let subcategory = category.implementations(db);
        let nodes = subcategory
            .values()
            .flatten()
            .enumerate()
            .map(|(idx, node)| ImplementationRef::new(
                node.fully_qualified_name(db),
                idx,
                self.codebase.clone(),
            ))
            .collect();
        Ok(nodes)
    }
}
mod cst {
    use pyo3::prelude::*;
    use std::sync::Arc;
    use pyo3::sync::GILProtected;
    use codegen_sdk_resolution::CodebaseContext;
    use codegen_sdk_common::traits::CSTNode;
    #[pyclass]
    pub struct AbstractType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AbstractType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AbstractType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AbstractType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersand {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersand {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAmpersand<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersand {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersandAmpersand {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandAmpersand {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAmpersandAmpersand<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandAmpersand {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAmpersandEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAmpersandEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAs {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAs {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAs<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAs {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsterisk {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsterisk {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAsterisk<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsterisk {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsteriskEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAsteriskEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsteriskSlash {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskSlash {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAsteriskSlash<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskSlash {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAsync {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsync {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAsync<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsync {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAt {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAt {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAt<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAt {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousAwait {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAwait {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousAwait<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAwait {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBang {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBang {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousBang<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBang {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBangEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBangEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousBangEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBangEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousBreak {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBreak {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousBreak<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBreak {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCaret {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCaret {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousCaret<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCaret {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCaretEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCaretEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousCaretEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCaretEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCloseBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseBrace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousCloseBrace<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCloseBracket {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseBracket {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousCloseBracket<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseBracket {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousCloseParen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseParen {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousCloseParen<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseParen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousColon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousColon<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousColonColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousColonColon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousColonColon<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousColonColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousComma {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousComma {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousComma<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousComma {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousConst {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousConst {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousConst<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousConst {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousContinue {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousContinue {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousContinue<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousContinue {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDefault {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDefault {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDefault<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDefault {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDollar {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDollar {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDollar<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDollar {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDot {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDot<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDotDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDotDot {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDotDot<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDotDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDotDotDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDotDotDot {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDotDotDot<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDotDotDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDotDotEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDotDotEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDotDotEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDotDotEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDoubleQuote {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDoubleQuote {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDoubleQuote<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDoubleQuote {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousDyn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDyn {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousDyn<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDyn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousElse {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousElse {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousElse<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousElse {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEnum {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEnum {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousEnum<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEnum {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousEqualsEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousEqualsGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousEqualsGreaterThan<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousExpr {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousExpr {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousExpr<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousExpr {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousExtern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousExtern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousExtern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousExtern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFalse {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFalse {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousFalse<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFalse {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFn {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousFn<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousFor {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFor {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousFor<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFor {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGen {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousGen<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousGreaterThan<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousGreaterThanEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousGreaterThanGreaterThan<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousGreaterThanGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_rust::cst::AnonymousGreaterThanGreaterThanEquals<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousHash {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousHash {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousHash<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousHash {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousIdent {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIdent {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousIdent<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIdent {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousIf {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIf {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousIf<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIf {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousImpl {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousImpl {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousImpl<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousImpl {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousIn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIn {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousIn<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLessThan<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLessThanEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThanLessThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanLessThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLessThanLessThan<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanLessThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLessThanLessThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanLessThanEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLessThanLessThanEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanLessThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLet {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLet<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLifetime {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLifetime {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLifetime<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLifetime {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousLoop {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLoop {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousLoop<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLoop {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMacroRulesBang {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMacroRulesBang {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMacroRulesBang<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMacroRulesBang {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMatch {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMatch {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMatch<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMatch {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMeta {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMeta {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMeta<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMeta {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinus {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMinus<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinusEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMinusEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMinusGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusGreaterThan {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMinusGreaterThan<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMod {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMod {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMod<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMod {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousMove {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMove {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousMove<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMove {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBrace {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousOpenBrace<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenBracket {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBracket {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousOpenBracket<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBracket {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousOpenParen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenParen {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousOpenParen<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenParen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPat {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPat {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPat<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPat {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPath {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPath {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPath<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPath {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPercent {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPercent {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPercent<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPercent {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPercentEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPercentEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPercentEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPercentEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipe {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPipe<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipeEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipeEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPipeEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipeEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPipePipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipePipe {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPipePipe<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipePipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPlus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlus {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPlus<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPlusEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPlusEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousPub {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPub {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousPub<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPub {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousQuestionMark {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMark {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousQuestionMark<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMark {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousRaw {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousRaw {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousRaw<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousRaw {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousRef {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousRef {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousRef<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousRef {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousReturn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousReturn {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousReturn<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousReturn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSemicolon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSemicolon {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousSemicolon<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSemicolon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSingleQuote {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSingleQuote {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousSingleQuote<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSingleQuote {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSlash {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlash {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousSlash<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlash {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSlashAsterisk {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlashAsterisk {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousSlashAsterisk<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlashAsterisk {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSlashEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlashEquals {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousSlashEquals<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlashEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousSlashSlash {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlashSlash {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousSlashSlash<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlashSlash {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousStatic {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousStatic {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousStatic<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousStatic {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousStmt {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousStmt {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousStmt<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousStmt {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousStruct {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousStruct {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousStruct<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousStruct {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTrait {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTrait {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousTrait<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTrait {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTrue {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTrue {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousTrue<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTrue {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTry {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTry {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousTry<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTry {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTt {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTt {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousTt<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTt {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousTy {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTy {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousTy<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTy {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUnderscore {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUnderscore {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousUnderscore<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUnderscore {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUnion {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUnion {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousUnion<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUnion {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUnsafe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUnsafe {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousUnsafe<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUnsafe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousUse {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUse {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousUse<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUse {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousVis {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousVis {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousVis<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousVis {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousWhere {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousWhere {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousWhere<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousWhere {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousWhile {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousWhile {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousWhile<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousWhile {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AnonymousYield {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousYield {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AnonymousYield<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousYield {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Arguments {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Arguments {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Arguments<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Arguments {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ArrayExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrayExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ArrayExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ArrayExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ArrayType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrayType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ArrayType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ArrayType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AssignmentExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssignmentExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AssignmentExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AssignmentExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AssociatedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssociatedType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AssociatedType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AssociatedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AsyncBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AsyncBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AsyncBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AsyncBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Attribute {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Attribute {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Attribute<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Attribute {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AttributeItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AttributeItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AttributeItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AttributeItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct AwaitExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AwaitExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::AwaitExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AwaitExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BaseFieldInitializer {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BaseFieldInitializer {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BaseFieldInitializer<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BaseFieldInitializer {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BinaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BinaryExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BinaryExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BinaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Block {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Block {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Block<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Block {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BlockComment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BlockComment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BlockComment<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BlockComment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BooleanLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BooleanLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BooleanLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BooleanLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BoundedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BoundedType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BoundedType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BoundedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BracketedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BracketedType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BracketedType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BracketedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct BreakExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BreakExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::BreakExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BreakExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CallExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CallExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::CallExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CallExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CapturedPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CapturedPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::CapturedPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CapturedPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CharLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CharLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::CharLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CharLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ClosureExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClosureExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ClosureExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ClosureExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ClosureParameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClosureParameters {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ClosureParameters<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ClosureParameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct CompoundAssignmentExpr {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CompoundAssignmentExpr {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::CompoundAssignmentExpr<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CompoundAssignmentExpr {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConstBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ConstBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConstBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConstItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ConstItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConstItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConstParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ConstParameter<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConstParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ConstrainedTypeParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstrainedTypeParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ConstrainedTypeParameter<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConstrainedTypeParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ContinueExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ContinueExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ContinueExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ContinueExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Crate {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Crate {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Crate<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Crate {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct DeclarationList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DeclarationList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::DeclarationList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl DeclarationList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct DocComment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DocComment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::DocComment<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl DocComment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct DynamicType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DynamicType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::DynamicType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl DynamicType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ElseClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ElseClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ElseClause<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ElseClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EmptyStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EmptyStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::EmptyStatement<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EmptyStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EnumItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::EnumItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EnumItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EnumVariant {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumVariant {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::EnumVariant<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EnumVariant {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EnumVariantList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumVariantList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::EnumVariantList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EnumVariantList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct EscapeSequence {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EscapeSequence {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::EscapeSequence<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EscapeSequence {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExpressionStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExpressionStatement {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ExpressionStatement<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExpressionStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExternCrateDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExternCrateDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ExternCrateDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExternCrateDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ExternModifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExternModifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ExternModifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExternModifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldDeclarationList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldDeclarationList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldDeclarationList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldDeclarationList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldInitializer {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldInitializer {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldInitializer<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldInitializer {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldInitializerList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldInitializerList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldInitializerList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldInitializerList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FieldPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FieldPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FieldPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FieldPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FloatLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FloatLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FloatLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FloatLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ForExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ForExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ForExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ForLifetimes {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForLifetimes {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ForLifetimes<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ForLifetimes {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ForeignModItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForeignModItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ForeignModItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ForeignModItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FragmentSpecifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FragmentSpecifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FragmentSpecifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FragmentSpecifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FunctionItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionModifiers {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionModifiers {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FunctionModifiers<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionModifiers {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionSignatureItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionSignatureItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FunctionSignatureItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionSignatureItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct FunctionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::FunctionType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GenBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GenBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::GenBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GenBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GenericFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GenericFunction {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::GenericFunction<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GenericFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GenericType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GenericType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::GenericType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GenericType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct GenericTypeWithTurbofish {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GenericTypeWithTurbofish {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::GenericTypeWithTurbofish<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GenericTypeWithTurbofish {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct HigherRankedTraitBound {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl HigherRankedTraitBound {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::HigherRankedTraitBound<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl HigherRankedTraitBound {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Identifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Identifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Identifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Identifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IfExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IfExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::IfExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IfExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ImplItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImplItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ImplItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImplItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IndexExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IndexExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::IndexExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IndexExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InnerAttributeItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InnerAttributeItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::InnerAttributeItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InnerAttributeItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct InnerDocCommentMarker {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InnerDocCommentMarker {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::InnerDocCommentMarker<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InnerDocCommentMarker {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct IntegerLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IntegerLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::IntegerLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IntegerLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Label {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Label {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Label<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Label {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LetChain {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LetChain {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::LetChain<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LetChain {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LetCondition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LetCondition {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::LetCondition<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LetCondition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LetDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LetDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::LetDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LetDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Lifetime {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Lifetime {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Lifetime<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Lifetime {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LineComment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LineComment {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::LineComment<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LineComment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct LoopExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LoopExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::LoopExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LoopExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MacroDefinition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MacroDefinition {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MacroDefinition<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MacroDefinition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MacroInvocation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MacroInvocation {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MacroInvocation<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MacroInvocation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MacroRule {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MacroRule {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MacroRule<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MacroRule {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MatchArm {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MatchArm {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MatchArm<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MatchArm {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MatchBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MatchBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MatchBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MatchBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MatchExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MatchExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MatchExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MatchExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MatchPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MatchPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MatchPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MatchPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Metavariable {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Metavariable {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Metavariable<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Metavariable {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ModItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ModItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ModItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ModItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MutPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MutPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MutPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MutPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct MutableSpecifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MutableSpecifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::MutableSpecifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MutableSpecifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NegativeLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NegativeLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::NegativeLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NegativeLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct NeverType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NeverType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::NeverType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NeverType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OptionalTypeParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalTypeParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::OptionalTypeParameter<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalTypeParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OrPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OrPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::OrPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OrPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OrderedFieldDeclarationList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OrderedFieldDeclarationList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::OrderedFieldDeclarationList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OrderedFieldDeclarationList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct OuterDocCommentMarker {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OuterDocCommentMarker {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::OuterDocCommentMarker<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OuterDocCommentMarker {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Parameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Parameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Parameter<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Parameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Parameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Parameters {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Parameters<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Parameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ParenthesizedExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ParenthesizedExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ParenthesizedExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ParenthesizedExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PointerType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PointerType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::PointerType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PointerType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct PrimitiveType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PrimitiveType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::PrimitiveType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PrimitiveType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct QualifiedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl QualifiedType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::QualifiedType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl QualifiedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RangeExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RangeExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::RangeExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RangeExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RangePattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RangePattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::RangePattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RangePattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RawStringLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RawStringLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::RawStringLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RawStringLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RefPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RefPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::RefPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RefPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ReferenceExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReferenceExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ReferenceExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ReferenceExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ReferencePattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReferencePattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ReferencePattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ReferencePattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ReferenceType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReferenceType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ReferenceType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ReferenceType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RemainingFieldPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RemainingFieldPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::RemainingFieldPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RemainingFieldPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct RemovedTraitBound {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RemovedTraitBound {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::RemovedTraitBound<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RemovedTraitBound {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ReturnExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReturnExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ReturnExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ReturnExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ScopedIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ScopedIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ScopedIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ScopedIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ScopedTypeIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ScopedTypeIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ScopedTypeIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ScopedTypeIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ScopedUseList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ScopedUseList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ScopedUseList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ScopedUseList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SelfNode {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SelfNode {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::SelfNode<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SelfNode {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SelfParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SelfParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::SelfParameter<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SelfParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Shebang {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Shebang {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Shebang<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Shebang {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ShorthandFieldIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ShorthandFieldIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ShorthandFieldIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ShorthandFieldIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct ShorthandFieldInitializer {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ShorthandFieldInitializer {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::ShorthandFieldInitializer<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ShorthandFieldInitializer {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SlicePattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SlicePattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::SlicePattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SlicePattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct SourceFile {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SourceFile {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::SourceFile<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SourceFile {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StaticItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StaticItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::StaticItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StaticItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StringContent {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StringContent {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::StringContent<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StringContent {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StringLiteral {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StringLiteral {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::StringLiteral<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StringLiteral {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StructExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StructExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::StructExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StructExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StructItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StructItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::StructItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StructItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct StructPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StructPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::StructPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StructPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct Super {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Super {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::Super<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Super {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TokenBindingPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TokenBindingPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TokenBindingPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TokenBindingPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TokenRepetition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TokenRepetition {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TokenRepetition<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TokenRepetition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TokenRepetitionPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TokenRepetitionPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TokenRepetitionPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TokenRepetitionPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TokenTree {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TokenTree {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TokenTree<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TokenTree {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TokenTreePattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TokenTreePattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TokenTreePattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TokenTreePattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TraitBounds {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TraitBounds {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TraitBounds<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TraitBounds {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TraitItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TraitItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TraitItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TraitItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TryBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TryBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TryBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TryBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TryExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TryExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TupleExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TupleExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TupleExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TupleExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TuplePattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TuplePattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TuplePattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TuplePattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TupleStructPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TupleStructPattern {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TupleStructPattern<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TupleStructPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TupleType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TupleType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TupleType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TupleType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeArguments {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeArguments {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TypeArguments<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeArguments {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeBinding {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeBinding {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TypeBinding<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeBinding {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeCastExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeCastExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TypeCastExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeCastExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeIdentifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TypeIdentifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TypeItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct TypeParameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeParameters {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::TypeParameters<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeParameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnaryExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UnaryExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnionItem {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnionItem {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UnionItem<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnionItem {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnitExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnitExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UnitExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnitExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnitType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnitType {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UnitType<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnitType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UnsafeBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnsafeBlock {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UnsafeBlock<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnsafeBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UseAsClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UseAsClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UseAsClause<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UseAsClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UseDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UseDeclaration {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UseDeclaration<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UseDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UseList {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UseList {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UseList<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UseList {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct UseWildcard {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UseWildcard {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::UseWildcard<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UseWildcard {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct VariadicParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl VariadicParameter {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::VariadicParameter<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl VariadicParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct VisibilityModifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl VisibilityModifier {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::VisibilityModifier<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl VisibilityModifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct WhereClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WhereClause {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::WhereClause<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl WhereClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct WherePredicate {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WherePredicate {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::WherePredicate<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl WherePredicate {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct WhileExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WhileExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::WhileExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl WhileExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    #[pyclass]
    pub struct YieldExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl YieldExpression {
        pub fn new(
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> Self {
            Self { id, codebase }
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<&'db codegen_sdk_rust::cst::YieldExpression<'db>> {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let tree = file.tree(codebase.db());
            let node = tree.get(self.id.id(codebase.db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl YieldExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
    }
    pub fn register_cst(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
        let child_module = PyModule::new(parent_module.py(), "cst")?;
        child_module.add_class::<AbstractType>()?;
        child_module.add_class::<AnonymousAmpersand>()?;
        child_module.add_class::<AnonymousAmpersandAmpersand>()?;
        child_module.add_class::<AnonymousAmpersandEquals>()?;
        child_module.add_class::<AnonymousAs>()?;
        child_module.add_class::<AnonymousAsterisk>()?;
        child_module.add_class::<AnonymousAsteriskEquals>()?;
        child_module.add_class::<AnonymousAsteriskSlash>()?;
        child_module.add_class::<AnonymousAsync>()?;
        child_module.add_class::<AnonymousAt>()?;
        child_module.add_class::<AnonymousAwait>()?;
        child_module.add_class::<AnonymousBang>()?;
        child_module.add_class::<AnonymousBangEquals>()?;
        child_module.add_class::<AnonymousBlock>()?;
        child_module.add_class::<AnonymousBreak>()?;
        child_module.add_class::<AnonymousCaret>()?;
        child_module.add_class::<AnonymousCaretEquals>()?;
        child_module.add_class::<AnonymousCloseBrace>()?;
        child_module.add_class::<AnonymousCloseBracket>()?;
        child_module.add_class::<AnonymousCloseParen>()?;
        child_module.add_class::<AnonymousColon>()?;
        child_module.add_class::<AnonymousColonColon>()?;
        child_module.add_class::<AnonymousComma>()?;
        child_module.add_class::<AnonymousConst>()?;
        child_module.add_class::<AnonymousContinue>()?;
        child_module.add_class::<AnonymousDefault>()?;
        child_module.add_class::<AnonymousDollar>()?;
        child_module.add_class::<AnonymousDot>()?;
        child_module.add_class::<AnonymousDotDot>()?;
        child_module.add_class::<AnonymousDotDotDot>()?;
        child_module.add_class::<AnonymousDotDotEquals>()?;
        child_module.add_class::<AnonymousDoubleQuote>()?;
        child_module.add_class::<AnonymousDyn>()?;
        child_module.add_class::<AnonymousElse>()?;
        child_module.add_class::<AnonymousEnum>()?;
        child_module.add_class::<AnonymousEquals>()?;
        child_module.add_class::<AnonymousEqualsEquals>()?;
        child_module.add_class::<AnonymousEqualsGreaterThan>()?;
        child_module.add_class::<AnonymousExpr>()?;
        child_module.add_class::<AnonymousExtern>()?;
        child_module.add_class::<AnonymousFalse>()?;
        child_module.add_class::<AnonymousFn>()?;
        child_module.add_class::<AnonymousFor>()?;
        child_module.add_class::<AnonymousGen>()?;
        child_module.add_class::<AnonymousGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanEquals>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanEquals>()?;
        child_module.add_class::<AnonymousHash>()?;
        child_module.add_class::<AnonymousIdent>()?;
        child_module.add_class::<AnonymousIf>()?;
        child_module.add_class::<AnonymousImpl>()?;
        child_module.add_class::<AnonymousIn>()?;
        child_module.add_class::<AnonymousItem>()?;
        child_module.add_class::<AnonymousLessThan>()?;
        child_module.add_class::<AnonymousLessThanEquals>()?;
        child_module.add_class::<AnonymousLessThanLessThan>()?;
        child_module.add_class::<AnonymousLessThanLessThanEquals>()?;
        child_module.add_class::<AnonymousLet>()?;
        child_module.add_class::<AnonymousLifetime>()?;
        child_module.add_class::<AnonymousLiteral>()?;
        child_module.add_class::<AnonymousLoop>()?;
        child_module.add_class::<AnonymousMacroRulesBang>()?;
        child_module.add_class::<AnonymousMatch>()?;
        child_module.add_class::<AnonymousMeta>()?;
        child_module.add_class::<AnonymousMinus>()?;
        child_module.add_class::<AnonymousMinusEquals>()?;
        child_module.add_class::<AnonymousMinusGreaterThan>()?;
        child_module.add_class::<AnonymousMod>()?;
        child_module.add_class::<AnonymousMove>()?;
        child_module.add_class::<AnonymousOpenBrace>()?;
        child_module.add_class::<AnonymousOpenBracket>()?;
        child_module.add_class::<AnonymousOpenParen>()?;
        child_module.add_class::<AnonymousPat>()?;
        child_module.add_class::<AnonymousPath>()?;
        child_module.add_class::<AnonymousPercent>()?;
        child_module.add_class::<AnonymousPercentEquals>()?;
        child_module.add_class::<AnonymousPipe>()?;
        child_module.add_class::<AnonymousPipeEquals>()?;
        child_module.add_class::<AnonymousPipePipe>()?;
        child_module.add_class::<AnonymousPlus>()?;
        child_module.add_class::<AnonymousPlusEquals>()?;
        child_module.add_class::<AnonymousPub>()?;
        child_module.add_class::<AnonymousQuestionMark>()?;
        child_module.add_class::<AnonymousRaw>()?;
        child_module.add_class::<AnonymousRef>()?;
        child_module.add_class::<AnonymousReturn>()?;
        child_module.add_class::<AnonymousSemicolon>()?;
        child_module.add_class::<AnonymousSingleQuote>()?;
        child_module.add_class::<AnonymousSlash>()?;
        child_module.add_class::<AnonymousSlashAsterisk>()?;
        child_module.add_class::<AnonymousSlashEquals>()?;
        child_module.add_class::<AnonymousSlashSlash>()?;
        child_module.add_class::<AnonymousStatic>()?;
        child_module.add_class::<AnonymousStmt>()?;
        child_module.add_class::<AnonymousStruct>()?;
        child_module.add_class::<AnonymousTrait>()?;
        child_module.add_class::<AnonymousTrue>()?;
        child_module.add_class::<AnonymousTry>()?;
        child_module.add_class::<AnonymousTt>()?;
        child_module.add_class::<AnonymousTy>()?;
        child_module.add_class::<AnonymousType>()?;
        child_module.add_class::<AnonymousUnderscore>()?;
        child_module.add_class::<AnonymousUnion>()?;
        child_module.add_class::<AnonymousUnsafe>()?;
        child_module.add_class::<AnonymousUse>()?;
        child_module.add_class::<AnonymousVis>()?;
        child_module.add_class::<AnonymousWhere>()?;
        child_module.add_class::<AnonymousWhile>()?;
        child_module.add_class::<AnonymousYield>()?;
        child_module.add_class::<Arguments>()?;
        child_module.add_class::<ArrayExpression>()?;
        child_module.add_class::<ArrayType>()?;
        child_module.add_class::<AssignmentExpression>()?;
        child_module.add_class::<AssociatedType>()?;
        child_module.add_class::<AsyncBlock>()?;
        child_module.add_class::<Attribute>()?;
        child_module.add_class::<AttributeItem>()?;
        child_module.add_class::<AwaitExpression>()?;
        child_module.add_class::<BaseFieldInitializer>()?;
        child_module.add_class::<BinaryExpression>()?;
        child_module.add_class::<Block>()?;
        child_module.add_class::<BlockComment>()?;
        child_module.add_class::<BooleanLiteral>()?;
        child_module.add_class::<BoundedType>()?;
        child_module.add_class::<BracketedType>()?;
        child_module.add_class::<BreakExpression>()?;
        child_module.add_class::<CallExpression>()?;
        child_module.add_class::<CapturedPattern>()?;
        child_module.add_class::<CharLiteral>()?;
        child_module.add_class::<ClosureExpression>()?;
        child_module.add_class::<ClosureParameters>()?;
        child_module.add_class::<CompoundAssignmentExpr>()?;
        child_module.add_class::<ConstBlock>()?;
        child_module.add_class::<ConstItem>()?;
        child_module.add_class::<ConstParameter>()?;
        child_module.add_class::<ConstrainedTypeParameter>()?;
        child_module.add_class::<ContinueExpression>()?;
        child_module.add_class::<Crate>()?;
        child_module.add_class::<DeclarationList>()?;
        child_module.add_class::<DocComment>()?;
        child_module.add_class::<DynamicType>()?;
        child_module.add_class::<ElseClause>()?;
        child_module.add_class::<EmptyStatement>()?;
        child_module.add_class::<EnumItem>()?;
        child_module.add_class::<EnumVariant>()?;
        child_module.add_class::<EnumVariantList>()?;
        child_module.add_class::<EscapeSequence>()?;
        child_module.add_class::<ExpressionStatement>()?;
        child_module.add_class::<ExternCrateDeclaration>()?;
        child_module.add_class::<ExternModifier>()?;
        child_module.add_class::<FieldDeclaration>()?;
        child_module.add_class::<FieldDeclarationList>()?;
        child_module.add_class::<FieldExpression>()?;
        child_module.add_class::<FieldIdentifier>()?;
        child_module.add_class::<FieldInitializer>()?;
        child_module.add_class::<FieldInitializerList>()?;
        child_module.add_class::<FieldPattern>()?;
        child_module.add_class::<FloatLiteral>()?;
        child_module.add_class::<ForExpression>()?;
        child_module.add_class::<ForLifetimes>()?;
        child_module.add_class::<ForeignModItem>()?;
        child_module.add_class::<FragmentSpecifier>()?;
        child_module.add_class::<FunctionItem>()?;
        child_module.add_class::<FunctionModifiers>()?;
        child_module.add_class::<FunctionSignatureItem>()?;
        child_module.add_class::<FunctionType>()?;
        child_module.add_class::<GenBlock>()?;
        child_module.add_class::<GenericFunction>()?;
        child_module.add_class::<GenericType>()?;
        child_module.add_class::<GenericTypeWithTurbofish>()?;
        child_module.add_class::<HigherRankedTraitBound>()?;
        child_module.add_class::<Identifier>()?;
        child_module.add_class::<IfExpression>()?;
        child_module.add_class::<ImplItem>()?;
        child_module.add_class::<IndexExpression>()?;
        child_module.add_class::<InnerAttributeItem>()?;
        child_module.add_class::<InnerDocCommentMarker>()?;
        child_module.add_class::<IntegerLiteral>()?;
        child_module.add_class::<Label>()?;
        child_module.add_class::<LetChain>()?;
        child_module.add_class::<LetCondition>()?;
        child_module.add_class::<LetDeclaration>()?;
        child_module.add_class::<Lifetime>()?;
        child_module.add_class::<LineComment>()?;
        child_module.add_class::<LoopExpression>()?;
        child_module.add_class::<MacroDefinition>()?;
        child_module.add_class::<MacroInvocation>()?;
        child_module.add_class::<MacroRule>()?;
        child_module.add_class::<MatchArm>()?;
        child_module.add_class::<MatchBlock>()?;
        child_module.add_class::<MatchExpression>()?;
        child_module.add_class::<MatchPattern>()?;
        child_module.add_class::<Metavariable>()?;
        child_module.add_class::<ModItem>()?;
        child_module.add_class::<MutPattern>()?;
        child_module.add_class::<MutableSpecifier>()?;
        child_module.add_class::<NegativeLiteral>()?;
        child_module.add_class::<NeverType>()?;
        child_module.add_class::<OptionalTypeParameter>()?;
        child_module.add_class::<OrPattern>()?;
        child_module.add_class::<OrderedFieldDeclarationList>()?;
        child_module.add_class::<OuterDocCommentMarker>()?;
        child_module.add_class::<Parameter>()?;
        child_module.add_class::<Parameters>()?;
        child_module.add_class::<ParenthesizedExpression>()?;
        child_module.add_class::<PointerType>()?;
        child_module.add_class::<PrimitiveType>()?;
        child_module.add_class::<QualifiedType>()?;
        child_module.add_class::<RangeExpression>()?;
        child_module.add_class::<RangePattern>()?;
        child_module.add_class::<RawStringLiteral>()?;
        child_module.add_class::<RefPattern>()?;
        child_module.add_class::<ReferenceExpression>()?;
        child_module.add_class::<ReferencePattern>()?;
        child_module.add_class::<ReferenceType>()?;
        child_module.add_class::<RemainingFieldPattern>()?;
        child_module.add_class::<RemovedTraitBound>()?;
        child_module.add_class::<ReturnExpression>()?;
        child_module.add_class::<ScopedIdentifier>()?;
        child_module.add_class::<ScopedTypeIdentifier>()?;
        child_module.add_class::<ScopedUseList>()?;
        child_module.add_class::<SelfNode>()?;
        child_module.add_class::<SelfParameter>()?;
        child_module.add_class::<Shebang>()?;
        child_module.add_class::<ShorthandFieldIdentifier>()?;
        child_module.add_class::<ShorthandFieldInitializer>()?;
        child_module.add_class::<SlicePattern>()?;
        child_module.add_class::<SourceFile>()?;
        child_module.add_class::<StaticItem>()?;
        child_module.add_class::<StringContent>()?;
        child_module.add_class::<StringLiteral>()?;
        child_module.add_class::<StructExpression>()?;
        child_module.add_class::<StructItem>()?;
        child_module.add_class::<StructPattern>()?;
        child_module.add_class::<Super>()?;
        child_module.add_class::<TokenBindingPattern>()?;
        child_module.add_class::<TokenRepetition>()?;
        child_module.add_class::<TokenRepetitionPattern>()?;
        child_module.add_class::<TokenTree>()?;
        child_module.add_class::<TokenTreePattern>()?;
        child_module.add_class::<TraitBounds>()?;
        child_module.add_class::<TraitItem>()?;
        child_module.add_class::<TryBlock>()?;
        child_module.add_class::<TryExpression>()?;
        child_module.add_class::<TupleExpression>()?;
        child_module.add_class::<TuplePattern>()?;
        child_module.add_class::<TupleStructPattern>()?;
        child_module.add_class::<TupleType>()?;
        child_module.add_class::<TypeArguments>()?;
        child_module.add_class::<TypeBinding>()?;
        child_module.add_class::<TypeCastExpression>()?;
        child_module.add_class::<TypeIdentifier>()?;
        child_module.add_class::<TypeItem>()?;
        child_module.add_class::<TypeParameters>()?;
        child_module.add_class::<UnaryExpression>()?;
        child_module.add_class::<UnionItem>()?;
        child_module.add_class::<UnitExpression>()?;
        child_module.add_class::<UnitType>()?;
        child_module.add_class::<UnsafeBlock>()?;
        child_module.add_class::<UseAsClause>()?;
        child_module.add_class::<UseDeclaration>()?;
        child_module.add_class::<UseList>()?;
        child_module.add_class::<UseWildcard>()?;
        child_module.add_class::<VariadicParameter>()?;
        child_module.add_class::<VisibilityModifier>()?;
        child_module.add_class::<WhereClause>()?;
        child_module.add_class::<WherePredicate>()?;
        child_module.add_class::<WhileExpression>()?;
        child_module.add_class::<YieldExpression>()?;
        parent_module.add_submodule(&child_module)?;
        Ok(())
    }
}
#[pyclass]
pub struct Class {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Class {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Class<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .classes(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Class {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::TypeItem> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::TypeItem::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct Function {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Function {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Function<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .functions(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Function {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::FunctionItem> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::FunctionItem::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct Interface {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Interface {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Interface<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .interfaces(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Interface {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::TraitItem> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::TraitItem::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct Macro {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Macro {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Macro<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .macros(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Macro {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::MacroDefinition> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::MacroDefinition::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct Method {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Method {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Method<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .methods(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Method {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::DeclarationList> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::DeclarationList::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct Module {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Module {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Module<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .modules(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Module {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::ModItem> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::ModItem::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct Call {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Call {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::Call<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .references(codebase.db())
            .calls(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Call {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::MacroInvocation> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::MacroInvocation::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
#[pyclass]
pub struct ImplementationRef {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl ImplementationRef {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_rust::ast::ImplementationRef<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Rust(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .references(codebase.db())
            .implementations(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl ImplementationRef {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::ImplItem> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::ImplItem::new(node.node_id(db), self.codebase.clone()))
    }
    fn source(&self, py: Python<'_>) -> PyResult<String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.source(py)?)
    }
}
pub fn register_rust(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let child_module = PyModule::new(parent_module.py(), "rust")?;
    child_module.add_class::<RustFile>()?;
    child_module.add_class::<Class>()?;
    child_module.add_class::<Function>()?;
    child_module.add_class::<Interface>()?;
    child_module.add_class::<Macro>()?;
    child_module.add_class::<Method>()?;
    child_module.add_class::<Module>()?;
    child_module.add_class::<Call>()?;
    child_module.add_class::<ImplementationRef>()?;
    parent_module.add_submodule(&child_module)?;
    cst::register_cst(&child_module)?;
    Ok(())
}

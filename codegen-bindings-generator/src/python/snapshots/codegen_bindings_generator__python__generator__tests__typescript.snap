---
source: codegen-bindings-generator/src/python/generator.rs
expression: format_code(&output).unwrap()
---
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct TypescriptFile {
    path: PathBuf,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl TypescriptFile {
    pub fn new(
        path: PathBuf,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { path, codebase }
    }
    fn file<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<
        &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
    > {
        let codebase = self.codebase.get(py);
        if let codegen_sdk_analyzer::ParsedFile::Typescript(file) = codebase
            .get_file(&self.path)
            .unwrap()
        {
            Ok(file)
        } else {
            Err(
                pyo3::exceptions::PyValueError::new_err(
                    format!("File not found at {}", self.path.display()),
                ),
            )
        }
    }
}
#[pymethods]
impl TypescriptFile {
    #[getter]
    pub fn path(&self) -> &PathBuf {
        &self.path
    }
    #[getter]
    pub fn content(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let codebase = self.codebase.get(py);
        let file = self.file(py)?.root(codebase.db());
        Ok(file.source())
    }
    #[getter]
    pub fn content_bytes(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
        let codebase = self.codebase.get(py);
        let file = self.file(py)?.root(codebase.db());
        Ok(pyo3_bytes::PyBytes::new(file.text()))
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<String> {
        Ok(self.content(py)?.to_string())
    }
    #[getter]
    pub fn classes(&self, py: Python<'_>) -> PyResult<Vec<Class>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.classes(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| Class::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_class(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<Class>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.classes(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        Class::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
    #[getter]
    pub fn functions(&self, py: Python<'_>) -> PyResult<Vec<Function>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.functions(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| Function::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_function(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<Function>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.functions(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        Function::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
    #[getter]
    pub fn interfaces(&self, py: Python<'_>) -> PyResult<Vec<Interface>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.interfaces(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| Interface::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_interface(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<Interface>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.interfaces(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        Interface::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
    #[getter]
    pub fn methods(&self, py: Python<'_>) -> PyResult<Vec<Method>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.methods(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| Method::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_method(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<Method>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.methods(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        Method::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
    #[getter]
    pub fn modules(&self, py: Python<'_>) -> PyResult<Vec<Module>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.modules(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| Module::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_module(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<Module>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.definitions(db);
        let subcategory = category.modules(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        Module::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
    #[getter]
    pub fn class_refs(&self, py: Python<'_>) -> PyResult<Vec<ClassRef>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.references(db);
        let subcategory = category.classes(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| ClassRef::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_class_ref(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<ClassRef>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.references(db);
        let subcategory = category.classes(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        ClassRef::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
    #[getter]
    pub fn type_refs(&self, py: Python<'_>) -> PyResult<Vec<TypeRef>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.references(db);
        let subcategory = category.types(db);
        let nodes = subcategory
            .values()
            .map(|values| {
                values
                    .into_iter()
                    .enumerate()
                    .map(|(idx, node)| TypeRef::new(
                        node.fully_qualified_name(db),
                        idx,
                        self.codebase.clone(),
                    ))
            })
            .flatten()
            .collect();
        Ok(nodes)
    }
    #[pyo3(signature = (name, optional = false))]
    pub fn get_type_ref(
        &self,
        py: Python<'_>,
        name: String,
        optional: bool,
    ) -> PyResult<Option<TypeRef>> {
        let file = self.file(py)?;
        let db = self.codebase.get(py).db();
        let category = file.references(db);
        let subcategory = category.types(db);
        let res = subcategory.get(&name);
        if let Some(nodes) = res {
            if nodes.len() == 1 {
                Ok(
                    Some(
                        TypeRef::new(
                            nodes[0].fully_qualified_name(db),
                            0,
                            self.codebase.clone(),
                        ),
                    ),
                )
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "Ambiguous symbol {} found {} possible matches", name, nodes
                            .len()
                        ),
                    ),
                )
            }
        } else {
            if optional {
                Ok(None)
            } else {
                Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!("No symbol {} found", name),
                    ),
                )
            }
        }
    }
}
mod cst {
    use pyo3::prelude::*;
    use std::sync::Arc;
    use pyo3::sync::GILProtected;
    use codegen_sdk_resolution::CodebaseContext;
    use codegen_sdk_common::traits::CSTNode;
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AbstractClassDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AbstractClassDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AbstractClassDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<AbstractClassDeclarationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AbstractClassDeclarationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AbstractMethodSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AbstractMethodSignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignature<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AbstractMethodSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<AbstractMethodSignatureChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AbstractMethodSignatureChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AccessibilityModifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AccessibilityModifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AccessibilityModifier<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AccessibilityModifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AddingTypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AddingTypeAnnotation {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotation<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AddingTypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<AddingTypeAnnotationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AddingTypeAnnotationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AmbientDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AmbientDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AmbientDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<AmbientDeclarationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AmbientDeclarationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAbstract {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAbstract {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAbstract<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAbstract {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAccessor {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAccessor {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAccessor<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAccessor {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAmpersand {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersand {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAmpersand<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersand {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAmpersandAmpersand {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandAmpersand {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAmpersandAmpersand<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandAmpersand {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAmpersandAmpersandEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandAmpersandEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAmpersandAmpersandEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandAmpersandEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAmpersandEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAmpersandEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAmpersandEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAmpersandEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAny {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAny {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAny<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAny {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAs {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAs {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAs<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAs {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAssert {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAssert {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAssert<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAssert {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAsserts {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsserts {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAsserts<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsserts {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAsterisk {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsterisk {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAsterisk<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsterisk {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAsteriskAsterisk {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskAsterisk {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAsteriskAsterisk<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskAsterisk {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAsteriskAsteriskEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskAsteriskEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAsteriskAsteriskEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskAsteriskEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAsteriskEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsteriskEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAsteriskEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsteriskEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAsync {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAsync {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAsync<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAsync {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAt {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAt {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAt<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAt {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousAwait {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousAwait {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousAwait<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousAwait {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousBacktick {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBacktick {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousBacktick<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBacktick {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousBang {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBang {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousBang<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBang {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousBangEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBangEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousBangEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBangEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousBangEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBangEqualsEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousBangEqualsEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBangEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousBoolean {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBoolean {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousBoolean<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBoolean {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousBreak {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousBreak {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousBreak<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousBreak {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCaret {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCaret {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCaret<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCaret {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCaretEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCaretEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCaretEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCaretEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCase {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCase {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCase<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCase {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCatch {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCatch {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCatch<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCatch {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousClass {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousClass {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousClass<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousClass {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCloseBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseBrace {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCloseBrace<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCloseBracket {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseBracket {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCloseBracket<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseBracket {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousCloseParen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousCloseParen {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousCloseParen<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousCloseParen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousColon {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousColon<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousComma {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousComma {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousComma<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousComma {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousConst {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousConst {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousConst<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousConst {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousContinue {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousContinue {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousContinue<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousContinue {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDebugger {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDebugger {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDebugger<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDebugger {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDeclare {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDeclare {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDeclare<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDeclare {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDefault {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDefault {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDefault<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDefault {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDelete {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDelete {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDelete<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDelete {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDo {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDo {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDo<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDo {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDollarOpenBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDollarOpenBrace {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDollarOpenBrace<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDollarOpenBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDot {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDot<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDotDotDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDotDotDot {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDotDotDot<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDotDotDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousDoubleQuote {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousDoubleQuote {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousDoubleQuote<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousDoubleQuote {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousElse {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousElse {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousElse<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousElse {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousEnum {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEnum {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousEnum<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEnum {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousEquals<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousEqualsEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousEqualsEqualsEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsEqualsEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousEqualsEqualsEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsEqualsEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousEqualsGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousEqualsGreaterThan {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousEqualsGreaterThan<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousEqualsGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousExport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousExport {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousExport<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousExport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousExtends {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousExtends {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousExtends<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousExtends {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousFinally {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFinally {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousFinally<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFinally {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousFor {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFor {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousFor<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFor {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousFrom {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFrom {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousFrom<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFrom {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousFunction {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousFunction<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGet {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGet<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGlobal {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGlobal {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGlobal<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGlobal {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThan {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGreaterThan<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGreaterThanEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGreaterThanGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThan {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThan<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGreaterThanGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThanEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGreaterThanGreaterThanGreaterThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanGreaterThan {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThanGreaterThan<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanGreaterThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousGreaterThanGreaterThanGreaterThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousGreaterThanGreaterThanGreaterThanEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousGreaterThanGreaterThanGreaterThanEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousGreaterThanGreaterThanGreaterThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousIf {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIf {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousIf<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIf {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousImplements {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousImplements {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousImplements<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousImplements {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousImport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousImport {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousImport<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousImport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousIn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIn {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousIn<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousInfer {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousInfer {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousInfer<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousInfer {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousInstanceof {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousInstanceof {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousInstanceof<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousInstanceof {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousInterface {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousInterface {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousInterface<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousInterface {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousIs {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousIs {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousIs<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousIs {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousKeyof {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousKeyof {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousKeyof<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousKeyof {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousLessThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThan {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousLessThan<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousLessThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousLessThanEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousLessThanLessThan {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanLessThan {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousLessThanLessThan<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanLessThan {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousLessThanLessThanEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLessThanLessThanEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousLessThanLessThanEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLessThanLessThanEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousLet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousLet {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousLet<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousLet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousMeta {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMeta {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousMeta<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMeta {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousMinus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinus {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousMinus<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousMinusEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousMinusEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousMinusMinus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusMinus {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousMinusMinus<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusMinus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousMinusQuestionMarkColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousMinusQuestionMarkColon {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousMinusQuestionMarkColon<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousMinusQuestionMarkColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousModule {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousModule {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousModule<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousModule {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousNamespace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNamespace {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousNamespace<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNamespace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousNever {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNever {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousNever<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNever {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousNew {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNew {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousNew<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNew {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousNumber {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousNumber {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousNumber<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousNumber {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousObject {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousObject {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousObject<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousObject {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousOf {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOf {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousOf<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOf {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousOpenBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBrace {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousOpenBrace<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousOpenBracePipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBracePipe {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousOpenBracePipe<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBracePipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousOpenBracket {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenBracket {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousOpenBracket<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenBracket {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousOpenParen {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOpenParen {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousOpenParen<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOpenParen {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousOverride {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousOverride {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousOverride<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousOverride {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPercent {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPercent {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPercent<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPercent {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPercentEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPercentEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPercentEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPercentEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipe {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPipe<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPipeCloseBrace {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipeCloseBrace {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPipeCloseBrace<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipeCloseBrace {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPipeEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipeEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPipeEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipeEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPipePipe {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipePipe {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPipePipe<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipePipe {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPipePipeEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPipePipeEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPipePipeEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPipePipeEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPlus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlus {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPlus<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPlusEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPlusEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPlusPlus {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusPlus {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPlusPlus<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusPlus {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPlusQuestionMarkColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPlusQuestionMarkColon {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPlusQuestionMarkColon<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPlusQuestionMarkColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPrivate {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPrivate {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPrivate<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPrivate {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousProtected {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousProtected {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousProtected<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousProtected {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousPublic {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousPublic {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousPublic<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousPublic {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousQuestionMark {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMark {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousQuestionMark<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMark {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousQuestionMarkColon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkColon {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousQuestionMarkColon<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkColon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousQuestionMarkDot {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkDot {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousQuestionMarkDot<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkDot {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousQuestionMarkQuestionMark {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkQuestionMark {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousQuestionMarkQuestionMark<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkQuestionMark {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousQuestionMarkQuestionMarkEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousQuestionMarkQuestionMarkEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousQuestionMarkQuestionMarkEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousQuestionMarkQuestionMarkEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousReadonly {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousReadonly {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousReadonly<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousReadonly {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousRequire {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousRequire {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousRequire<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousRequire {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousReturn {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousReturn {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousReturn<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousReturn {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSatisfies {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSatisfies {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSatisfies<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSatisfies {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSemicolon {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSemicolon {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSemicolon<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSemicolon {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSet {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSet {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSet<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSet {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSingleQuote {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSingleQuote {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSingleQuote<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSingleQuote {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSlash {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlash {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSlash<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlash {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSlashEquals {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSlashEquals {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSlashEquals<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSlashEquals {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousStatic {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousStatic {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousStatic<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousStatic {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousString {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousString {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousString<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousString {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSwitch {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSwitch {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSwitch<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSwitch {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousSymbol {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousSymbol {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousSymbol<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousSymbol {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousTarget {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTarget {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousTarget<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTarget {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousThrow {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousThrow {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousThrow<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousThrow {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousTilde {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTilde {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousTilde<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTilde {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousTry {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTry {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousTry<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTry {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousTypeof {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousTypeof {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousTypeof<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousTypeof {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousUniqueSymbol {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUniqueSymbol {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousUniqueSymbol<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUniqueSymbol {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousUnknown {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUnknown {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousUnknown<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUnknown {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousUsing {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousUsing {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousUsing<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousUsing {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousVar {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousVar {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousVar<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousVar {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousVoid {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousVoid {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousVoid<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousVoid {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousWhile {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousWhile {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousWhile<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousWhile {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousWith {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousWith {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousWith<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousWith {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AnonymousYield {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AnonymousYield {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AnonymousYield<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AnonymousYield {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Arguments {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Arguments {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Arguments<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Arguments {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ArgumentsChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ArgumentsChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Array {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Array {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Array<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Array {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ArrayChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ArrayChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ArrayPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrayPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPattern<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ArrayPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ArrayPatternChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ArrayPatternChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ArrayType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrayType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ArrayType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ArrayTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ArrayTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ArrowFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ArrowFunction {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunction<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ArrowFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AsExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AsExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AsExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<AsExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AsExpressionChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Asserts {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Asserts {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Asserts<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Asserts {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<AssertsChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AssertsChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AssertsAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssertsAnnotation {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsAnnotation<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AssertsAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<AssertsAnnotationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AssertsAnnotationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AssignmentExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssignmentExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AssignmentExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AssignmentPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AssignmentPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPattern<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AssignmentPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AugmentedAssignmentExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AugmentedAssignmentExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AugmentedAssignmentExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct AwaitExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl AwaitExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl AwaitExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<AwaitExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        AwaitExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct BinaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BinaryExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BinaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct BreakStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl BreakStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::BreakStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl BreakStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct CallExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CallExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CallExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct CallSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CallSignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignature<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CallSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct CatchClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl CatchClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl CatchClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Class {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Class {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Class<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Class {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ClassChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ClassChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ClassBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassBody {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBody<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ClassBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ClassBodyChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ClassBodyChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ClassDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclaration<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ClassDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ClassDeclarationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ClassDeclarationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ClassHeritage {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassHeritage {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassHeritage<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ClassHeritage {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ClassHeritageChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ClassHeritageChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ClassStaticBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ClassStaticBlock {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassStaticBlock<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ClassStaticBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Comment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Comment {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Comment<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Comment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ComputedPropertyName {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ComputedPropertyName {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyName<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ComputedPropertyName {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ComputedPropertyNameChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ComputedPropertyNameChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ConditionalType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConditionalType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConditionalType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Constraint {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Constraint {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Constraint<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Constraint {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ConstraintChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ConstraintChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ConstructSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstructSignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructSignature<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConstructSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ConstructorType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ConstructorType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ConstructorType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ContinueStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ContinueStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ContinueStatement<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ContinueStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct DebuggerStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DebuggerStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::DebuggerStatement<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl DebuggerStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Decorator {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Decorator {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Decorator<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Decorator {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<DecoratorChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        DecoratorChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct DefaultType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DefaultType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl DefaultType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<DefaultTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        DefaultTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct DoStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl DoStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl DoStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ElseClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ElseClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ElseClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ElseClauseChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ElseClauseChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct EmptyStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EmptyStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::EmptyStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EmptyStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct EnumAssignment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumAssignment {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignment<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EnumAssignment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct EnumBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumBody {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBody<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EnumBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<EnumBodyChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        EnumBodyChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct EnumDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EnumDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumDeclaration<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EnumDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct EscapeSequence {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl EscapeSequence {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::EscapeSequence<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl EscapeSequence {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExistentialType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExistentialType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExistentialType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExistentialType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExportClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExportClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExportClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ExportClauseChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ExportClauseChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExportSpecifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExportSpecifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifier<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExportSpecifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExportStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExportStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExportStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ExportStatementChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ExportStatementChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExpressionStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExpressionStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatement<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExpressionStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ExpressionStatementChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ExpressionStatementChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExtendsClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExtendsClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExtendsClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ExtendsTypeClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ExtendsTypeClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClause<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ExtendsTypeClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct False {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl False {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::False<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl False {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FinallyClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FinallyClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FinallyClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FinallyClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FlowMaybeType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FlowMaybeType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FlowMaybeType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<FlowMaybeTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        FlowMaybeTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ForInStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForInStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ForInStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ForStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ForStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ForStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FormalParameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FormalParameters {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FormalParameters<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FormalParameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<FormalParametersChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        FormalParametersChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FunctionDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FunctionExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FunctionSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionSignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignature<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct FunctionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl FunctionType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl FunctionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct GeneratorFunction {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GeneratorFunction {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunction<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GeneratorFunction {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct GeneratorFunctionDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GeneratorFunctionDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GeneratorFunctionDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct GenericType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl GenericType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl GenericType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct HashBangLine {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl HashBangLine {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::HashBangLine<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl HashBangLine {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct HtmlComment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl HtmlComment {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::HtmlComment<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl HtmlComment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Identifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Identifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Identifier<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Identifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct IfStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IfStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IfStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImplementsClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImplementsClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImplementsClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ImplementsClauseChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ImplementsClauseChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Import {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Import {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Import<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Import {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImportAlias {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportAlias {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAlias<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImportAlias {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ImportAliasChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ImportAliasChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImportAttribute {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportAttribute {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAttribute<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImportAttribute {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ImportAttributeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ImportAttributeChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImportClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImportClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ImportClauseChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ImportClauseChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImportRequireClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportRequireClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportRequireClause<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImportRequireClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ImportRequireClauseChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ImportRequireClauseChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImportSpecifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportSpecifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportSpecifier<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImportSpecifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ImportStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ImportStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ImportStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ImportStatementChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ImportStatementChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct IndexSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IndexSignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignature<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IndexSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<IndexSignatureChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        IndexSignatureChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct IndexTypeQuery {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IndexTypeQuery {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQuery<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IndexTypeQuery {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<IndexTypeQueryChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        IndexTypeQueryChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct InferType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InferType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InferType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<InferTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        InferTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct InstantiationExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InstantiationExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InstantiationExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<InstantiationExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        InstantiationExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct InterfaceBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InterfaceBody {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBody<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InterfaceBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<InterfaceBodyChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        InterfaceBodyChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct InterfaceDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InterfaceDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InterfaceDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<InterfaceDeclarationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        InterfaceDeclarationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct InternalModule {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl InternalModule {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModule<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl InternalModule {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct IntersectionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl IntersectionType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl IntersectionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<IntersectionTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        IntersectionTypeChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct LabeledStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LabeledStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LabeledStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct LexicalDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LexicalDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LexicalDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<LexicalDeclarationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        LexicalDeclarationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct LiteralType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LiteralType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LiteralType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<LiteralTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        LiteralTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct LookupType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl LookupType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl LookupType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<LookupTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        LookupTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct MappedTypeClause {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MappedTypeClause {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClause<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MappedTypeClause {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct MemberExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MemberExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MemberExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct MetaProperty {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MetaProperty {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::MetaProperty<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MetaProperty {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct MethodDefinition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MethodDefinition {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinition<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MethodDefinition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<MethodDefinitionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        MethodDefinitionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct MethodSignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl MethodSignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignature<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl MethodSignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<MethodSignatureChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        MethodSignatureChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Module {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Module {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Module<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Module {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NamedImports {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NamedImports {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamedImports<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NamedImports {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<NamedImportsChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        NamedImportsChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NamespaceExport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NamespaceExport {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceExport<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NamespaceExport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<NamespaceExportChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        NamespaceExportChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NamespaceImport {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NamespaceImport {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceImport<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NamespaceImport {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<NamespaceImportChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        NamespaceImportChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NestedIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NestedIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifier<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NestedIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NestedTypeIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NestedTypeIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifier<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NestedTypeIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NewExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NewExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NewExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct NonNullExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl NonNullExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl NonNullExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<NonNullExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        NonNullExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Null {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Null {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Null<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Null {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Number {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Number {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Number<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Number {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Object {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Object {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Object<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Object {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ObjectChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ObjectChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ObjectAssignmentPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ObjectAssignmentPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPattern<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ObjectAssignmentPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ObjectPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ObjectPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectPattern<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ObjectPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ObjectPatternChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ObjectPatternChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ObjectType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ObjectType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ObjectType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ObjectTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ObjectTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct OmittingTypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OmittingTypeAnnotation {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotation<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OmittingTypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<OmittingTypeAnnotationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        OmittingTypeAnnotationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct OptingTypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptingTypeAnnotation {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotation<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OptingTypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<OptingTypeAnnotationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        OptingTypeAnnotationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct OptionalChain {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalChain {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalChain<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalChain {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct OptionalParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalParameter {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameter<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<OptionalParameterChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        OptionalParameterChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct OptionalType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OptionalType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OptionalType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<OptionalTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        OptionalTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct OverrideModifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl OverrideModifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::OverrideModifier<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl OverrideModifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Pair {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Pair {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Pair<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Pair {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct PairPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PairPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPattern<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PairPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ParenthesizedExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ParenthesizedExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ParenthesizedExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ParenthesizedExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ParenthesizedExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ParenthesizedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ParenthesizedType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedType<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ParenthesizedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ParenthesizedTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ParenthesizedTypeChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct PredefinedType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PredefinedType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::PredefinedType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PredefinedType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct PrivatePropertyIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PrivatePropertyIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrivatePropertyIdentifier<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PrivatePropertyIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Program {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Program {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Program<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Program {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ProgramChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ProgramChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct PropertyIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PropertyIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertyIdentifier<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PropertyIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct PropertySignature {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PropertySignature {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignature<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PropertySignature {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<PropertySignatureChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        PropertySignatureChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct PublicFieldDefinition {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl PublicFieldDefinition {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinition<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl PublicFieldDefinition {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<PublicFieldDefinitionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        PublicFieldDefinitionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ReadonlyType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReadonlyType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ReadonlyType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ReadonlyTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ReadonlyTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Regex {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Regex {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Regex<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Regex {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct RegexFlags {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RegexFlags {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::RegexFlags<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RegexFlags {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct RegexPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RegexPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::RegexPattern<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RegexPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct RequiredParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RequiredParameter {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameter<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RequiredParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<RequiredParameterChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        RequiredParameterChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct RestPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RestPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPattern<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RestPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<RestPatternChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        RestPatternChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct RestType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl RestType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl RestType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<RestTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        RestTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ReturnStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ReturnStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ReturnStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<ReturnStatementChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ReturnStatementChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SatisfiesExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SatisfiesExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SatisfiesExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<SatisfiesExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        SatisfiesExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SequenceExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SequenceExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SequenceExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<SequenceExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        SequenceExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ShorthandPropertyIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ShorthandPropertyIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ShorthandPropertyIdentifier<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ShorthandPropertyIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ShorthandPropertyIdentifierPattern {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ShorthandPropertyIdentifierPattern {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ShorthandPropertyIdentifierPattern<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ShorthandPropertyIdentifierPattern {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SpreadElement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SpreadElement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SpreadElement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<SpreadElementChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        SpreadElementChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct StatementBlock {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StatementBlock {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlock<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StatementBlock {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<StatementBlockChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        StatementBlockChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct StatementIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StatementIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementIdentifier<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StatementIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct String {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl String {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::String<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl String {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<StringChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        StringChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct StringFragment {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl StringFragment {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::StringFragment<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl StringFragment {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SubscriptExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SubscriptExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SubscriptExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Super {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Super {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Super<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Super {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SwitchBody {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchBody {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchBody<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchBody {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<SwitchBodyChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        SwitchBodyChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SwitchCase {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchCase {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCase<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchCase {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SwitchDefault {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchDefault {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefault<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchDefault {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct SwitchStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl SwitchStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl SwitchStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TemplateLiteralType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateLiteralType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateLiteralType<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateLiteralType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<TemplateLiteralTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TemplateLiteralTypeChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TemplateString {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateString {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateString<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateString {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TemplateStringChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TemplateStringChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TemplateSubstitution {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateSubstitution {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitution<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateSubstitution {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<TemplateSubstitutionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TemplateSubstitutionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TemplateType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TemplateType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TemplateType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TemplateTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TemplateTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TernaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TernaryExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpression<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TernaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct This {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl This {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::This<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl This {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ThisType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ThisType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThisType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ThisType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct ThrowStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl ThrowStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl ThrowStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<ThrowStatementChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        ThrowStatementChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct True {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl True {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::True<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl True {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TryStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TryStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TryStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TryStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TupleType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TupleType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TupleType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TupleTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TupleTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeAliasDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeAliasDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeAliasDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeAnnotation {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotation<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TypeAnnotationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TypeAnnotationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeArguments {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeArguments {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArguments<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeArguments {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TypeArgumentsChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TypeArgumentsChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeAssertion {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeAssertion {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertion<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeAssertion {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TypeAssertionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TypeAssertionChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeIdentifier {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeIdentifier {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeIdentifier<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeIdentifier {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeParameter {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeParameter {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParameter<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeParameter {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeParameters {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeParameters {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParameters<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeParameters {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TypeParametersChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TypeParametersChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypePredicate {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypePredicate {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicate<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypePredicate {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypePredicateAnnotation {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypePredicateAnnotation {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateAnnotation<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypePredicateAnnotation {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<TypePredicateAnnotationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TypePredicateAnnotationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct TypeQuery {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl TypeQuery {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQuery<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl TypeQuery {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<TypeQueryChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        TypeQueryChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct UnaryExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnaryExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnaryExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct Undefined {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl Undefined {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::Undefined<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl Undefined {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct UnionType {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UnionType {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionType<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UnionType {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(&self, py: Python<'_>) -> PyResult<Vec<UnionTypeChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        UnionTypeChildren::new(py.clone(), id, self.codebase.clone())
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct UpdateExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl UpdateExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl UpdateExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct VariableDeclaration {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl VariableDeclaration {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaration<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl VariableDeclaration {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<VariableDeclarationChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        VariableDeclarationChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct VariableDeclarator {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl VariableDeclarator {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclarator<
                'db,
            >,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl VariableDeclarator {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct WhileStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WhileStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl WhileStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct WithStatement {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl WithStatement {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatement<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl WithStatement {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[pyclass(module = "codegen_sdk_pink::typescript.cst")]
    pub struct YieldExpression {
        id: codegen_sdk_common::CSTNodeTreeId,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    }
    impl YieldExpression {
        pub fn new(
            _py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            Ok(Self { id, codebase })
        }
        fn get_file<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypescriptFile<'db>,
        > {
            let codebase = self.codebase.get(py);
            let path = self.id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            Ok(file)
        }
        fn get_node<'db>(
            &'db self,
            py: Python<'db>,
        ) -> PyResult<
            &'db codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpression<'db>,
        > {
            let file = self.get_file(py)?;
            let tree = file.tree(self.codebase.get(py).db());
            let node = tree.get(self.id.id(self.codebase.get(py).db()));
            if let Some(node) = node {
                node.as_ref()
                    .try_into()
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(
                        format!("Failed to convert node to CSTNode {}", e),
                    ))
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[pymethods]
    impl YieldExpression {
        #[getter]
        pub fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            let node = self.get_node(py)?;
            Ok(node.source())
        }
        #[getter]
        pub fn _source(&self, py: Python<'_>) -> PyResult<std::string::String> {
            self.source(py)
        }
        #[getter]
        pub fn text(&self, py: Python<'_>) -> PyResult<pyo3_bytes::PyBytes> {
            let node = self.get_node(py)?;
            Ok(pyo3_bytes::PyBytes::new(node.text()))
        }
        #[getter]
        pub fn start_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.start_byte())
        }
        #[getter]
        pub fn end_byte(&self, py: Python<'_>) -> PyResult<usize> {
            let node = self.get_node(py)?;
            Ok(node.end_byte())
        }
        #[getter]
        pub fn start_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.start_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn end_position<'a>(
            &'a self,
            py: Python<'a>,
        ) -> PyResult<Bound<'a, pyo3::types::PyTuple>> {
            let node = self.get_node(py)?;
            let position = node.end_position();
            let row = position.row(self.codebase.get(py).db());
            let column = position.column(self.codebase.get(py).db());
            pyo3::types::PyTuple::new(py, vec![row, column])
        }
        #[getter]
        pub fn children(
            &self,
            py: Python<'_>,
        ) -> PyResult<Vec<YieldExpressionChildren>> {
            let file = self.get_file(py)?;
            let db = self.codebase.get(py).db();
            let tree = file.tree(db);
            let children = tree.children(self.id.id(db));
            Ok(
                children
                    .map(|(child, child_id)| {
                        let id = codegen_sdk_common::CSTNodeTreeId::from_node_id(
                            db,
                            &child.id(),
                            child_id,
                        );
                        YieldExpressionChildren::new(
                                py.clone(),
                                id,
                                self.codebase.clone(),
                            )
                            .unwrap()
                    })
                    .collect(),
            )
        }
        fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
            Ok(self.source(py)?)
        }
    }
    #[derive(IntoPyObject)]
    pub enum AbstractClassDeclarationChildren {
        ClassBody(ClassBody),
        ClassHeritage(ClassHeritage),
        Comment(Comment),
        Decorator(Decorator),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
    }
    impl AbstractClassDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclarationChildrenRef::ClassBody(
                        _,
                    ) => {
                        Ok(
                            Self::ClassBody(
                                ClassBody::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclarationChildrenRef::ClassHeritage(
                        _,
                    ) => {
                        Ok(
                            Self::ClassHeritage(
                                ClassHeritage::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclarationChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclarationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractClassDeclarationChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AbstractMethodSignatureChildren {
        AccessibilityModifier(AccessibilityModifier),
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        FormalParameters(FormalParameters),
        Number(Number),
        OverrideModifier(OverrideModifier),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl AbstractMethodSignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AbstractMethodSignatureName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl AbstractMethodSignatureName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AbstractMethodSignatureReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl AbstractMethodSignatureReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AbstractMethodSignatureReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AddingTypeAnnotationChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl AddingTypeAnnotationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AddingTypeAnnotationChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AmbientDeclarationChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        EnumDeclaration(EnumDeclaration),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        FunctionType(FunctionType),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        GenericType(GenericType),
        ImportAlias(ImportAlias),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        IntersectionType(IntersectionType),
        LexicalDeclaration(LexicalDeclaration),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        Module(Module),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        PropertyIdentifier(PropertyIdentifier),
        ReadonlyType(ReadonlyType),
        StatementBlock(StatementBlock),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeAliasDeclaration(TypeAliasDeclaration),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
        VariableDeclaration(VariableDeclaration),
    }
    impl AmbientDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AmbientDeclarationChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArgumentsChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SpreadElement(SpreadElement),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ArgumentsChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::SpreadElement(
                        _,
                    ) => {
                        Ok(
                            Self::SpreadElement(
                                SpreadElement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArgumentsChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArrayChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SpreadElement(SpreadElement),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ArrayChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::SpreadElement(
                        _,
                    ) => {
                        Ok(
                            Self::SpreadElement(
                                SpreadElement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArrayPatternChildren {
        ArrayPattern(ArrayPattern),
        AssignmentPattern(AssignmentPattern),
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        RestPattern(RestPattern),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl ArrayPatternChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::AssignmentPattern(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentPattern(
                                AssignmentPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayPatternChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArrayTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ArrayTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrayTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArrowFunctionBody {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        StatementBlock(StatementBlock),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ArrowFunctionBody {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionBodyRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArrowFunctionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssertsAnnotation(AssertsAnnotation),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FormalParameters(FormalParameters),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        StatementBlock(StatementBlock),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAnnotation(TypeAnnotation),
        TypeAssertion(TypeAssertion),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ArrowFunctionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ArrowFunctionReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl ArrowFunctionReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ArrowFunctionReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AsExpressionChildren {
        AnonymousConst(AnonymousConst),
        Array(Array),
        ArrayType(ArrayType),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        False(False),
        FlowMaybeType(FlowMaybeType),
        FunctionExpression(FunctionExpression),
        FunctionType(FunctionType),
        GeneratorFunction(GeneratorFunction),
        GenericType(GenericType),
        Identifier(Identifier),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NestedTypeIdentifier(NestedTypeIdentifier),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectType(ObjectType),
        ParenthesizedExpression(ParenthesizedExpression),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateLiteralType(TemplateLiteralType),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        ThisType(ThisType),
        True(True),
        TupleType(TupleType),
        TypeAssertion(TypeAssertion),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UnionType(UnionType),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl AsExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AsExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AssertsAnnotationChildren {
        Asserts(Asserts),
        Comment(Comment),
    }
    impl AssertsAnnotationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsAnnotationChildrenRef::Asserts(
                        _,
                    ) => Ok(Self::Asserts(Asserts::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsAnnotationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AssertsChildren {
        Comment(Comment),
        Identifier(Identifier),
        This(This),
        TypePredicate(TypePredicate),
    }
    impl AssertsChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssertsChildrenRef::TypePredicate(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicate(
                                TypePredicate::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AssignmentExpressionChildren {
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl AssignmentExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AssignmentExpressionLeft {
        ArrayPattern(ArrayPattern),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl AssignmentExpressionLeft {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentExpressionLeftRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AssignmentPatternChildren {
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        RestPattern(RestPattern),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl AssignmentPatternChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AssignmentPatternChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AugmentedAssignmentExpressionChildren {
        AnonymousAmpersandAmpersandEquals(AnonymousAmpersandAmpersandEquals),
        AnonymousAmpersandEquals(AnonymousAmpersandEquals),
        AnonymousAsteriskAsteriskEquals(AnonymousAsteriskAsteriskEquals),
        AnonymousAsteriskEquals(AnonymousAsteriskEquals),
        AnonymousCaretEquals(AnonymousCaretEquals),
        AnonymousGreaterThanGreaterThanEquals(AnonymousGreaterThanGreaterThanEquals),
        AnonymousGreaterThanGreaterThanGreaterThanEquals(
            AnonymousGreaterThanGreaterThanGreaterThanEquals,
        ),
        AnonymousLessThanLessThanEquals(AnonymousLessThanLessThanEquals),
        AnonymousMinusEquals(AnonymousMinusEquals),
        AnonymousPercentEquals(AnonymousPercentEquals),
        AnonymousPipeEquals(AnonymousPipeEquals),
        AnonymousPipePipeEquals(AnonymousPipePipeEquals),
        AnonymousPlusEquals(AnonymousPlusEquals),
        AnonymousQuestionMarkQuestionMarkEquals(AnonymousQuestionMarkQuestionMarkEquals),
        AnonymousSlashEquals(AnonymousSlashEquals),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl AugmentedAssignmentExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousAmpersandAmpersandEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersandAmpersandEquals(
                                AnonymousAmpersandAmpersandEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousAmpersandEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersandEquals(
                                AnonymousAmpersandEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousAsteriskAsteriskEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsteriskAsteriskEquals(
                                AnonymousAsteriskAsteriskEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousAsteriskEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsteriskEquals(
                                AnonymousAsteriskEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousCaretEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousCaretEquals(
                                AnonymousCaretEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousGreaterThanGreaterThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThanEquals(
                                AnonymousGreaterThanGreaterThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousGreaterThanGreaterThanGreaterThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThanGreaterThanEquals(
                                AnonymousGreaterThanGreaterThanGreaterThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousLessThanLessThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThanLessThanEquals(
                                AnonymousLessThanLessThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousMinusEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinusEquals(
                                AnonymousMinusEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousPercentEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPercentEquals(
                                AnonymousPercentEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousPipeEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipeEquals(
                                AnonymousPipeEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousPipePipeEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipePipeEquals(
                                AnonymousPipePipeEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousPlusEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlusEquals(
                                AnonymousPlusEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousQuestionMarkQuestionMarkEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousQuestionMarkQuestionMarkEquals(
                                AnonymousQuestionMarkQuestionMarkEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AnonymousSlashEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousSlashEquals(
                                AnonymousSlashEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AugmentedAssignmentExpressionLeft {
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ParenthesizedExpression(ParenthesizedExpression),
        SubscriptExpression(SubscriptExpression),
    }
    impl AugmentedAssignmentExpressionLeft {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionLeftRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionLeftRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionLeftRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionLeftRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionLeftRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AugmentedAssignmentExpressionOperator {
        AnonymousAmpersandAmpersandEquals(AnonymousAmpersandAmpersandEquals),
        AnonymousAmpersandEquals(AnonymousAmpersandEquals),
        AnonymousAsteriskAsteriskEquals(AnonymousAsteriskAsteriskEquals),
        AnonymousAsteriskEquals(AnonymousAsteriskEquals),
        AnonymousCaretEquals(AnonymousCaretEquals),
        AnonymousGreaterThanGreaterThanEquals(AnonymousGreaterThanGreaterThanEquals),
        AnonymousGreaterThanGreaterThanGreaterThanEquals(
            AnonymousGreaterThanGreaterThanGreaterThanEquals,
        ),
        AnonymousLessThanLessThanEquals(AnonymousLessThanLessThanEquals),
        AnonymousMinusEquals(AnonymousMinusEquals),
        AnonymousPercentEquals(AnonymousPercentEquals),
        AnonymousPipeEquals(AnonymousPipeEquals),
        AnonymousPipePipeEquals(AnonymousPipePipeEquals),
        AnonymousPlusEquals(AnonymousPlusEquals),
        AnonymousQuestionMarkQuestionMarkEquals(AnonymousQuestionMarkQuestionMarkEquals),
        AnonymousSlashEquals(AnonymousSlashEquals),
    }
    impl AugmentedAssignmentExpressionOperator {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousAmpersandAmpersandEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersandAmpersandEquals(
                                AnonymousAmpersandAmpersandEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousAmpersandEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersandEquals(
                                AnonymousAmpersandEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousAsteriskAsteriskEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsteriskAsteriskEquals(
                                AnonymousAsteriskAsteriskEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousAsteriskEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsteriskEquals(
                                AnonymousAsteriskEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousCaretEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousCaretEquals(
                                AnonymousCaretEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousGreaterThanGreaterThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThanEquals(
                                AnonymousGreaterThanGreaterThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousGreaterThanGreaterThanGreaterThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThanGreaterThanEquals(
                                AnonymousGreaterThanGreaterThanGreaterThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousLessThanLessThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThanLessThanEquals(
                                AnonymousLessThanLessThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousMinusEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinusEquals(
                                AnonymousMinusEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousPercentEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPercentEquals(
                                AnonymousPercentEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousPipeEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipeEquals(
                                AnonymousPipeEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousPipePipeEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipePipeEquals(
                                AnonymousPipePipeEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousPlusEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlusEquals(
                                AnonymousPlusEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousQuestionMarkQuestionMarkEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousQuestionMarkQuestionMarkEquals(
                                AnonymousQuestionMarkQuestionMarkEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AugmentedAssignmentExpressionOperatorRef::AnonymousSlashEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousSlashEquals(
                                AnonymousSlashEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum AwaitExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl AwaitExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::AwaitExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum BinaryExpressionChildren {
        AnonymousAmpersand(AnonymousAmpersand),
        AnonymousAmpersandAmpersand(AnonymousAmpersandAmpersand),
        AnonymousAsterisk(AnonymousAsterisk),
        AnonymousAsteriskAsterisk(AnonymousAsteriskAsterisk),
        AnonymousBangEquals(AnonymousBangEquals),
        AnonymousBangEqualsEquals(AnonymousBangEqualsEquals),
        AnonymousCaret(AnonymousCaret),
        AnonymousEqualsEquals(AnonymousEqualsEquals),
        AnonymousEqualsEqualsEquals(AnonymousEqualsEqualsEquals),
        AnonymousGreaterThan(AnonymousGreaterThan),
        AnonymousGreaterThanEquals(AnonymousGreaterThanEquals),
        AnonymousGreaterThanGreaterThan(AnonymousGreaterThanGreaterThan),
        AnonymousGreaterThanGreaterThanGreaterThan(
            AnonymousGreaterThanGreaterThanGreaterThan,
        ),
        AnonymousIn(AnonymousIn),
        AnonymousInstanceof(AnonymousInstanceof),
        AnonymousLessThan(AnonymousLessThan),
        AnonymousLessThanEquals(AnonymousLessThanEquals),
        AnonymousLessThanLessThan(AnonymousLessThanLessThan),
        AnonymousMinus(AnonymousMinus),
        AnonymousPercent(AnonymousPercent),
        AnonymousPipe(AnonymousPipe),
        AnonymousPipePipe(AnonymousPipePipe),
        AnonymousPlus(AnonymousPlus),
        AnonymousQuestionMarkQuestionMark(AnonymousQuestionMarkQuestionMark),
        AnonymousSlash(AnonymousSlash),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl BinaryExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousAmpersand(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersand(
                                AnonymousAmpersand::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousAmpersandAmpersand(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersandAmpersand(
                                AnonymousAmpersandAmpersand::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousAsterisk(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsterisk(
                                AnonymousAsterisk::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousAsteriskAsterisk(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsteriskAsterisk(
                                AnonymousAsteriskAsterisk::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousBangEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousBangEquals(
                                AnonymousBangEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousBangEqualsEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousBangEqualsEquals(
                                AnonymousBangEqualsEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousCaret(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousCaret(
                                AnonymousCaret::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousEqualsEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousEqualsEquals(
                                AnonymousEqualsEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousEqualsEqualsEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousEqualsEqualsEquals(
                                AnonymousEqualsEqualsEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousGreaterThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThan(
                                AnonymousGreaterThan::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousGreaterThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanEquals(
                                AnonymousGreaterThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousGreaterThanGreaterThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThan(
                                AnonymousGreaterThanGreaterThan::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousGreaterThanGreaterThanGreaterThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThanGreaterThan(
                                AnonymousGreaterThanGreaterThanGreaterThan::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousIn(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousIn(
                                AnonymousIn::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousInstanceof(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousInstanceof(
                                AnonymousInstanceof::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousLessThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThan(
                                AnonymousLessThan::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousLessThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThanEquals(
                                AnonymousLessThanEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousLessThanLessThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThanLessThan(
                                AnonymousLessThanLessThan::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinus(
                                AnonymousMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousPercent(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPercent(
                                AnonymousPercent::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousPipe(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipe(
                                AnonymousPipe::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousPipePipe(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipePipe(
                                AnonymousPipePipe::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlus(
                                AnonymousPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousQuestionMarkQuestionMark(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousQuestionMarkQuestionMark(
                                AnonymousQuestionMarkQuestionMark::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AnonymousSlash(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousSlash(
                                AnonymousSlash::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum BinaryExpressionLeft {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl BinaryExpressionLeft {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionLeftRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum BinaryExpressionOperator {
        AnonymousAmpersand(AnonymousAmpersand),
        AnonymousAmpersandAmpersand(AnonymousAmpersandAmpersand),
        AnonymousAsterisk(AnonymousAsterisk),
        AnonymousAsteriskAsterisk(AnonymousAsteriskAsterisk),
        AnonymousBangEquals(AnonymousBangEquals),
        AnonymousBangEqualsEquals(AnonymousBangEqualsEquals),
        AnonymousCaret(AnonymousCaret),
        AnonymousEqualsEquals(AnonymousEqualsEquals),
        AnonymousEqualsEqualsEquals(AnonymousEqualsEqualsEquals),
        AnonymousGreaterThan(AnonymousGreaterThan),
        AnonymousGreaterThanEquals(AnonymousGreaterThanEquals),
        AnonymousGreaterThanGreaterThan(AnonymousGreaterThanGreaterThan),
        AnonymousGreaterThanGreaterThanGreaterThan(
            AnonymousGreaterThanGreaterThanGreaterThan,
        ),
        AnonymousIn(AnonymousIn),
        AnonymousInstanceof(AnonymousInstanceof),
        AnonymousLessThan(AnonymousLessThan),
        AnonymousLessThanEquals(AnonymousLessThanEquals),
        AnonymousLessThanLessThan(AnonymousLessThanLessThan),
        AnonymousMinus(AnonymousMinus),
        AnonymousPercent(AnonymousPercent),
        AnonymousPipe(AnonymousPipe),
        AnonymousPipePipe(AnonymousPipePipe),
        AnonymousPlus(AnonymousPlus),
        AnonymousQuestionMarkQuestionMark(AnonymousQuestionMarkQuestionMark),
        AnonymousSlash(AnonymousSlash),
    }
    impl BinaryExpressionOperator {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousAmpersand(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersand(
                                AnonymousAmpersand::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousAmpersandAmpersand(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAmpersandAmpersand(
                                AnonymousAmpersandAmpersand::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousAsterisk(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsterisk(
                                AnonymousAsterisk::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousAsteriskAsterisk(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousAsteriskAsterisk(
                                AnonymousAsteriskAsterisk::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousBangEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousBangEquals(
                                AnonymousBangEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousBangEqualsEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousBangEqualsEquals(
                                AnonymousBangEqualsEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousCaret(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousCaret(
                                AnonymousCaret::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousEqualsEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousEqualsEquals(
                                AnonymousEqualsEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousEqualsEqualsEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousEqualsEqualsEquals(
                                AnonymousEqualsEqualsEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousGreaterThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThan(
                                AnonymousGreaterThan::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousGreaterThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanEquals(
                                AnonymousGreaterThanEquals::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousGreaterThanGreaterThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThan(
                                AnonymousGreaterThanGreaterThan::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousGreaterThanGreaterThanGreaterThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousGreaterThanGreaterThanGreaterThan(
                                AnonymousGreaterThanGreaterThanGreaterThan::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousIn(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousIn(
                                AnonymousIn::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousInstanceof(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousInstanceof(
                                AnonymousInstanceof::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousLessThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThan(
                                AnonymousLessThan::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousLessThanEquals(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThanEquals(
                                AnonymousLessThanEquals::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousLessThanLessThan(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLessThanLessThan(
                                AnonymousLessThanLessThan::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinus(
                                AnonymousMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousPercent(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPercent(
                                AnonymousPercent::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousPipe(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipe(
                                AnonymousPipe::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousPipePipe(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPipePipe(
                                AnonymousPipePipe::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlus(
                                AnonymousPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousQuestionMarkQuestionMark(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousQuestionMarkQuestionMark(
                                AnonymousQuestionMarkQuestionMark::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BinaryExpressionOperatorRef::AnonymousSlash(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousSlash(
                                AnonymousSlash::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum BreakStatementChildren {
        Comment(Comment),
        StatementIdentifier(StatementIdentifier),
    }
    impl BreakStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BreakStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::BreakStatementChildrenRef::StatementIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::StatementIdentifier(
                                StatementIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CallExpressionArguments {
        Arguments(Arguments),
        TemplateString(TemplateString),
    }
    impl CallExpressionArguments {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionArgumentsRef::Arguments(
                        _,
                    ) => {
                        Ok(
                            Self::Arguments(
                                Arguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionArgumentsRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CallExpressionChildren {
        Arguments(Arguments),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        Import(Import),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeArguments(TypeArguments),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl CallExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Arguments(
                        _,
                    ) => {
                        Ok(
                            Self::Arguments(
                                Arguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Import(
                        _,
                    ) => Ok(Self::Import(Import::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::TypeArguments(
                        _,
                    ) => {
                        Ok(
                            Self::TypeArguments(
                                TypeArguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CallExpressionFunction {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        Import(Import),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl CallExpressionFunction {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Import(
                        _,
                    ) => Ok(Self::Import(Import::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallExpressionFunctionRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CallSignatureChildren {
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        FormalParameters(FormalParameters),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl CallSignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CallSignatureReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl CallSignatureReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CallSignatureReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CatchClauseChildren {
        ArrayPattern(ArrayPattern),
        Comment(Comment),
        Identifier(Identifier),
        ObjectPattern(ObjectPattern),
        StatementBlock(StatementBlock),
        TypeAnnotation(TypeAnnotation),
    }
    impl CatchClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum CatchClauseParameter {
        ArrayPattern(ArrayPattern),
        Identifier(Identifier),
        ObjectPattern(ObjectPattern),
    }
    impl CatchClauseParameter {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseParameterRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseParameterRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::CatchClauseParameterRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ClassBodyChildren {
        AbstractMethodSignature(AbstractMethodSignature),
        ClassStaticBlock(ClassStaticBlock),
        Comment(Comment),
        Decorator(Decorator),
        IndexSignature(IndexSignature),
        MethodDefinition(MethodDefinition),
        MethodSignature(MethodSignature),
        PublicFieldDefinition(PublicFieldDefinition),
    }
    impl ClassBodyChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::AbstractMethodSignature(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractMethodSignature(
                                AbstractMethodSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::ClassStaticBlock(
                        _,
                    ) => {
                        Ok(
                            Self::ClassStaticBlock(
                                ClassStaticBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::IndexSignature(
                        _,
                    ) => {
                        Ok(
                            Self::IndexSignature(
                                IndexSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::MethodDefinition(
                        _,
                    ) => {
                        Ok(
                            Self::MethodDefinition(
                                MethodDefinition::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::MethodSignature(
                        _,
                    ) => {
                        Ok(
                            Self::MethodSignature(
                                MethodSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassBodyChildrenRef::PublicFieldDefinition(
                        _,
                    ) => {
                        Ok(
                            Self::PublicFieldDefinition(
                                PublicFieldDefinition::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ClassChildren {
        ClassBody(ClassBody),
        ClassHeritage(ClassHeritage),
        Comment(Comment),
        Decorator(Decorator),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
    }
    impl ClassChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassChildrenRef::ClassBody(
                        _,
                    ) => {
                        Ok(
                            Self::ClassBody(
                                ClassBody::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassChildrenRef::ClassHeritage(
                        _,
                    ) => {
                        Ok(
                            Self::ClassHeritage(
                                ClassHeritage::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ClassDeclarationChildren {
        ClassBody(ClassBody),
        ClassHeritage(ClassHeritage),
        Comment(Comment),
        Decorator(Decorator),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
    }
    impl ClassDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclarationChildrenRef::ClassBody(
                        _,
                    ) => {
                        Ok(
                            Self::ClassBody(
                                ClassBody::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclarationChildrenRef::ClassHeritage(
                        _,
                    ) => {
                        Ok(
                            Self::ClassHeritage(
                                ClassHeritage::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclarationChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclarationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassDeclarationChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ClassHeritageChildren {
        Comment(Comment),
        ExtendsClause(ExtendsClause),
        ImplementsClause(ImplementsClause),
    }
    impl ClassHeritageChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassHeritageChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassHeritageChildrenRef::ExtendsClause(
                        _,
                    ) => {
                        Ok(
                            Self::ExtendsClause(
                                ExtendsClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassHeritageChildrenRef::ImplementsClause(
                        _,
                    ) => {
                        Ok(
                            Self::ImplementsClause(
                                ImplementsClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ClassStaticBlockChildren {
        Comment(Comment),
        StatementBlock(StatementBlock),
    }
    impl ClassStaticBlockChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassStaticBlockChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ClassStaticBlockChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ComputedPropertyNameChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ComputedPropertyNameChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ComputedPropertyNameChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ConditionalTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ConditionalTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConditionalTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ConstraintChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ConstraintChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstraintChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ConstructSignatureChildren {
        Comment(Comment),
        FormalParameters(FormalParameters),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
    }
    impl ConstructSignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructSignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructSignatureChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructSignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructSignatureChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ConstructorTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FormalParameters(FormalParameters),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ConstructorTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ConstructorTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ContinueStatementChildren {
        Comment(Comment),
        StatementIdentifier(StatementIdentifier),
    }
    impl ContinueStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ContinueStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ContinueStatementChildrenRef::StatementIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::StatementIdentifier(
                                StatementIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum DecoratorChildren {
        CallExpression(CallExpression),
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        ParenthesizedExpression(ParenthesizedExpression),
    }
    impl DecoratorChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DecoratorChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DecoratorChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DecoratorChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DecoratorChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DecoratorChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum DefaultTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl DefaultTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DefaultTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum DoStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ParenthesizedExpression(ParenthesizedExpression),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl DoStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DoStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ElseClauseChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl ElseClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ElseClauseChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum EnumAssignmentChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl EnumAssignmentChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum EnumAssignmentName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl EnumAssignmentName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumAssignmentNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum EnumBodyChildren {
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        EnumAssignment(EnumAssignment),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl EnumBodyChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::EnumAssignment(
                        _,
                    ) => {
                        Ok(
                            Self::EnumAssignment(
                                EnumAssignment::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum EnumBodyName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl EnumBodyName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumBodyNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum EnumDeclarationChildren {
        Comment(Comment),
        EnumBody(EnumBody),
        Identifier(Identifier),
    }
    impl EnumDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumDeclarationChildrenRef::EnumBody(
                        _,
                    ) => Ok(Self::EnumBody(EnumBody::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::EnumDeclarationChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExportClauseChildren {
        Comment(Comment),
        ExportSpecifier(ExportSpecifier),
    }
    impl ExportClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportClauseChildrenRef::ExportSpecifier(
                        _,
                    ) => {
                        Ok(
                            Self::ExportSpecifier(
                                ExportSpecifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExportSpecifierAlias {
        Identifier(Identifier),
        String(String),
    }
    impl ExportSpecifierAlias {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierAliasRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierAliasRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExportSpecifierChildren {
        Comment(Comment),
        Identifier(Identifier),
        String(String),
    }
    impl ExportSpecifierChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExportSpecifierName {
        Identifier(Identifier),
        String(String),
    }
    impl ExportSpecifierName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportSpecifierNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExportStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        Decorator(Decorator),
        EnumDeclaration(EnumDeclaration),
        ExportClause(ExportClause),
        False(False),
        FunctionDeclaration(FunctionDeclaration),
        FunctionExpression(FunctionExpression),
        FunctionSignature(FunctionSignature),
        GeneratorFunction(GeneratorFunction),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        Identifier(Identifier),
        ImportAlias(ImportAlias),
        InstantiationExpression(InstantiationExpression),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LexicalDeclaration(LexicalDeclaration),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        Module(Module),
        NamespaceExport(NamespaceExport),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAliasDeclaration(TypeAliasDeclaration),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        VariableDeclaration(VariableDeclaration),
        YieldExpression(YieldExpression),
    }
    impl ExportStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::ExportClause(
                        _,
                    ) => {
                        Ok(
                            Self::ExportClause(
                                ExportClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::NamespaceExport(
                        _,
                    ) => {
                        Ok(
                            Self::NamespaceExport(
                                NamespaceExport::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExportStatementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExpressionStatementChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ExpressionStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionStatementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExtendsClauseChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeArguments(TypeArguments),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ExtendsClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::TypeArguments(
                        _,
                    ) => {
                        Ok(
                            Self::TypeArguments(
                                TypeArguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsClauseChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExtendsTypeClauseChildren {
        Comment(Comment),
        GenericType(GenericType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        TypeIdentifier(TypeIdentifier),
    }
    impl ExtendsTypeClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ExtendsTypeClauseType {
        GenericType(GenericType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        TypeIdentifier(TypeIdentifier),
    }
    impl ExtendsTypeClauseType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseTypeRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseTypeRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExtendsTypeClauseTypeRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FinallyClauseChildren {
        Comment(Comment),
        StatementBlock(StatementBlock),
    }
    impl FinallyClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FinallyClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FinallyClauseChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FlowMaybeTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl FlowMaybeTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FlowMaybeTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForInStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        AnonymousConst(AnonymousConst),
        AnonymousIn(AnonymousIn),
        AnonymousLet(AnonymousLet),
        AnonymousOf(AnonymousOf),
        AnonymousVar(AnonymousVar),
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        BreakStatement(BreakStatement),
        CallExpression(CallExpression),
        Class(Class),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        False(False),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionExpression(FunctionExpression),
        FunctionSignature(FunctionSignature),
        GeneratorFunction(GeneratorFunction),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        Identifier(Identifier),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InstantiationExpression(InstantiationExpression),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        Module(Module),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        ReturnStatement(ReturnStatement),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        StatementBlock(StatementBlock),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        SwitchStatement(SwitchStatement),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        ThrowStatement(ThrowStatement),
        True(True),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
        YieldExpression(YieldExpression),
    }
    impl ForInStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AnonymousIn(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousIn(
                                AnonymousIn::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AnonymousLet(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLet(
                                AnonymousLet::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AnonymousOf(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousOf(
                                AnonymousOf::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AnonymousVar(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousVar(
                                AnonymousVar::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForInStatementKind {
        AnonymousConst(AnonymousConst),
        AnonymousLet(AnonymousLet),
        AnonymousVar(AnonymousVar),
    }
    impl ForInStatementKind {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementKindRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementKindRef::AnonymousLet(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLet(
                                AnonymousLet::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementKindRef::AnonymousVar(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousVar(
                                AnonymousVar::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForInStatementLeft {
        ArrayPattern(ArrayPattern),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl ForInStatementLeft {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementLeftRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForInStatementOperator {
        AnonymousIn(AnonymousIn),
        AnonymousOf(AnonymousOf),
    }
    impl ForInStatementOperator {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementOperatorRef::AnonymousIn(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousIn(
                                AnonymousIn::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementOperatorRef::AnonymousOf(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousOf(
                                AnonymousOf::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForInStatementRight {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ForInStatementRight {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForInStatementRightRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        AnonymousSemicolon(AnonymousSemicolon),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        BreakStatement(BreakStatement),
        CallExpression(CallExpression),
        Class(Class),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        False(False),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionExpression(FunctionExpression),
        FunctionSignature(FunctionSignature),
        GeneratorFunction(GeneratorFunction),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        Identifier(Identifier),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InstantiationExpression(InstantiationExpression),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        Module(Module),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        ReturnStatement(ReturnStatement),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        StatementBlock(StatementBlock),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        SwitchStatement(SwitchStatement),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        ThrowStatement(ThrowStatement),
        True(True),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
        YieldExpression(YieldExpression),
    }
    impl ForStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AnonymousSemicolon(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousSemicolon(
                                AnonymousSemicolon::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForStatementCondition {
        AnonymousSemicolon(AnonymousSemicolon),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        EmptyStatement(EmptyStatement),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ForStatementCondition {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::AnonymousSemicolon(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousSemicolon(
                                AnonymousSemicolon::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementConditionRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForStatementIncrement {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ForStatementIncrement {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementIncrementRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ForStatementInitializer {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        EmptyStatement(EmptyStatement),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        LexicalDeclaration(LexicalDeclaration),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        VariableDeclaration(VariableDeclaration),
        YieldExpression(YieldExpression),
    }
    impl ForStatementInitializer {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ForStatementInitializerRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FormalParametersChildren {
        Comment(Comment),
        OptionalParameter(OptionalParameter),
        RequiredParameter(RequiredParameter),
    }
    impl FormalParametersChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FormalParametersChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FormalParametersChildrenRef::OptionalParameter(
                        _,
                    ) => {
                        Ok(
                            Self::OptionalParameter(
                                OptionalParameter::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FormalParametersChildrenRef::RequiredParameter(
                        _,
                    ) => {
                        Ok(
                            Self::RequiredParameter(
                                RequiredParameter::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionDeclarationChildren {
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        FormalParameters(FormalParameters),
        Identifier(Identifier),
        StatementBlock(StatementBlock),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl FunctionDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionDeclarationReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl FunctionDeclarationReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionDeclarationReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionExpressionChildren {
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        FormalParameters(FormalParameters),
        Identifier(Identifier),
        StatementBlock(StatementBlock),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl FunctionExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionExpressionReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl FunctionExpressionReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionExpressionReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionSignatureChildren {
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        FormalParameters(FormalParameters),
        Identifier(Identifier),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl FunctionSignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionSignatureReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl FunctionSignatureReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionSignatureReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        Asserts(Asserts),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FormalParameters(FormalParameters),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
        TypePredicate(TypePredicate),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl FunctionTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::Asserts(
                        _,
                    ) => Ok(Self::Asserts(Asserts::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::TypePredicate(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicate(
                                TypePredicate::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum FunctionTypeReturnType {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        Asserts(Asserts),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypePredicate(TypePredicate),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl FunctionTypeReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::Asserts(
                        _,
                    ) => Ok(Self::Asserts(Asserts::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::TypePredicate(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicate(
                                TypePredicate::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::FunctionTypeReturnTypeRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum GeneratorFunctionChildren {
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        FormalParameters(FormalParameters),
        Identifier(Identifier),
        StatementBlock(StatementBlock),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl GeneratorFunctionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum GeneratorFunctionDeclarationChildren {
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        FormalParameters(FormalParameters),
        Identifier(Identifier),
        StatementBlock(StatementBlock),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl GeneratorFunctionDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum GeneratorFunctionDeclarationReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl GeneratorFunctionDeclarationReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionDeclarationReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum GeneratorFunctionReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl GeneratorFunctionReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GeneratorFunctionReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum GenericTypeChildren {
        Comment(Comment),
        NestedTypeIdentifier(NestedTypeIdentifier),
        TypeArguments(TypeArguments),
        TypeIdentifier(TypeIdentifier),
    }
    impl GenericTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericTypeChildrenRef::TypeArguments(
                        _,
                    ) => {
                        Ok(
                            Self::TypeArguments(
                                TypeArguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum GenericTypeName {
        NestedTypeIdentifier(NestedTypeIdentifier),
        TypeIdentifier(TypeIdentifier),
    }
    impl GenericTypeName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericTypeNameRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::GenericTypeNameRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum IfStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        ElseClause(ElseClause),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ParenthesizedExpression(ParenthesizedExpression),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl IfStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ElseClause(
                        _,
                    ) => {
                        Ok(
                            Self::ElseClause(
                                ElseClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IfStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImplementsClauseChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ImplementsClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImplementsClauseChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportAliasChildren {
        Comment(Comment),
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
    }
    impl ImportAliasChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAliasChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAliasChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAliasChildrenRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportAttributeChildren {
        Comment(Comment),
        Object(Object),
    }
    impl ImportAttributeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAttributeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportAttributeChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportClauseChildren {
        Comment(Comment),
        Identifier(Identifier),
        NamedImports(NamedImports),
        NamespaceImport(NamespaceImport),
    }
    impl ImportClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportClauseChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportClauseChildrenRef::NamedImports(
                        _,
                    ) => {
                        Ok(
                            Self::NamedImports(
                                NamedImports::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportClauseChildrenRef::NamespaceImport(
                        _,
                    ) => {
                        Ok(
                            Self::NamespaceImport(
                                NamespaceImport::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportRequireClauseChildren {
        Comment(Comment),
        Identifier(Identifier),
        String(String),
    }
    impl ImportRequireClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportRequireClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportRequireClauseChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportRequireClauseChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportSpecifierChildren {
        Comment(Comment),
        Identifier(Identifier),
        String(String),
    }
    impl ImportSpecifierChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportSpecifierChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportSpecifierChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportSpecifierChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportSpecifierName {
        Identifier(Identifier),
        String(String),
    }
    impl ImportSpecifierName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportSpecifierNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportSpecifierNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ImportStatementChildren {
        Comment(Comment),
        ImportAttribute(ImportAttribute),
        ImportClause(ImportClause),
        ImportRequireClause(ImportRequireClause),
        String(String),
    }
    impl ImportStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportStatementChildrenRef::ImportAttribute(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAttribute(
                                ImportAttribute::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportStatementChildrenRef::ImportClause(
                        _,
                    ) => {
                        Ok(
                            Self::ImportClause(
                                ImportClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportStatementChildrenRef::ImportRequireClause(
                        _,
                    ) => {
                        Ok(
                            Self::ImportRequireClause(
                                ImportRequireClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ImportStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum IndexSignatureChildren {
        AddingTypeAnnotation(AddingTypeAnnotation),
        AnonymousConst(AnonymousConst),
        AnonymousMinus(AnonymousMinus),
        AnonymousPlus(AnonymousPlus),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        Identifier(Identifier),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MappedTypeClause(MappedTypeClause),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        OmittingTypeAnnotation(OmittingTypeAnnotation),
        OptingTypeAnnotation(OptingTypeAnnotation),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeAnnotation(TypeAnnotation),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl IndexSignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::AddingTypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AddingTypeAnnotation(
                                AddingTypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::AnonymousMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinus(
                                AnonymousMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::AnonymousPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlus(
                                AnonymousPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::MappedTypeClause(
                        _,
                    ) => {
                        Ok(
                            Self::MappedTypeClause(
                                MappedTypeClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::OmittingTypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::OmittingTypeAnnotation(
                                OmittingTypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::OptingTypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::OptingTypeAnnotation(
                                OptingTypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum IndexSignatureSign {
        AnonymousMinus(AnonymousMinus),
        AnonymousPlus(AnonymousPlus),
    }
    impl IndexSignatureSign {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureSignRef::AnonymousMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinus(
                                AnonymousMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureSignRef::AnonymousPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlus(
                                AnonymousPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum IndexSignatureType {
        AddingTypeAnnotation(AddingTypeAnnotation),
        OmittingTypeAnnotation(OmittingTypeAnnotation),
        OptingTypeAnnotation(OptingTypeAnnotation),
        TypeAnnotation(TypeAnnotation),
    }
    impl IndexSignatureType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureTypeRef::AddingTypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AddingTypeAnnotation(
                                AddingTypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureTypeRef::OmittingTypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::OmittingTypeAnnotation(
                                OmittingTypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureTypeRef::OptingTypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::OptingTypeAnnotation(
                                OptingTypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexSignatureTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum IndexTypeQueryChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl IndexTypeQueryChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IndexTypeQueryChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InferTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl InferTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InferTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InstantiationExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        Import(Import),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeArguments(TypeArguments),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl InstantiationExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Import(
                        _,
                    ) => Ok(Self::Import(Import::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::TypeArguments(
                        _,
                    ) => {
                        Ok(
                            Self::TypeArguments(
                                TypeArguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InstantiationExpressionFunction {
        Identifier(Identifier),
        Import(Import),
        MemberExpression(MemberExpression),
        SubscriptExpression(SubscriptExpression),
    }
    impl InstantiationExpressionFunction {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionFunctionRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionFunctionRef::Import(
                        _,
                    ) => Ok(Self::Import(Import::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionFunctionRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InstantiationExpressionFunctionRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InterfaceBodyChildren {
        CallSignature(CallSignature),
        Comment(Comment),
        ConstructSignature(ConstructSignature),
        ExportStatement(ExportStatement),
        IndexSignature(IndexSignature),
        MethodSignature(MethodSignature),
        PropertySignature(PropertySignature),
    }
    impl InterfaceBodyChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::CallSignature(
                        _,
                    ) => {
                        Ok(
                            Self::CallSignature(
                                CallSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::ConstructSignature(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructSignature(
                                ConstructSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::IndexSignature(
                        _,
                    ) => {
                        Ok(
                            Self::IndexSignature(
                                IndexSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::MethodSignature(
                        _,
                    ) => {
                        Ok(
                            Self::MethodSignature(
                                MethodSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceBodyChildrenRef::PropertySignature(
                        _,
                    ) => {
                        Ok(
                            Self::PropertySignature(
                                PropertySignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InterfaceDeclarationChildren {
        Comment(Comment),
        ExtendsTypeClause(ExtendsTypeClause),
        InterfaceBody(InterfaceBody),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
    }
    impl InterfaceDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceDeclarationChildrenRef::ExtendsTypeClause(
                        _,
                    ) => {
                        Ok(
                            Self::ExtendsTypeClause(
                                ExtendsTypeClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceDeclarationChildrenRef::InterfaceBody(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceBody(
                                InterfaceBody::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceDeclarationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InterfaceDeclarationChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InternalModuleChildren {
        Comment(Comment),
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
        StatementBlock(StatementBlock),
        String(String),
    }
    impl InternalModuleChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleChildrenRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum InternalModuleName {
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
        String(String),
    }
    impl InternalModuleName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleNameRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::InternalModuleNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum IntersectionTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl IntersectionTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::IntersectionTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum LabeledStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        StatementIdentifier(StatementIdentifier),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl LabeledStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::StatementIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::StatementIdentifier(
                                StatementIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LabeledStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum LexicalDeclarationChildren {
        AnonymousConst(AnonymousConst),
        AnonymousLet(AnonymousLet),
        Comment(Comment),
        VariableDeclarator(VariableDeclarator),
    }
    impl LexicalDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclarationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclarationChildrenRef::AnonymousLet(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLet(
                                AnonymousLet::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclarationChildrenRef::VariableDeclarator(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclarator(
                                VariableDeclarator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum LexicalDeclarationKind {
        AnonymousConst(AnonymousConst),
        AnonymousLet(AnonymousLet),
    }
    impl LexicalDeclarationKind {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclarationKindRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LexicalDeclarationKindRef::AnonymousLet(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousLet(
                                AnonymousLet::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum LiteralTypeChildren {
        Comment(Comment),
        False(False),
        Null(Null),
        Number(Number),
        String(String),
        True(True),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
    }
    impl LiteralTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LiteralTypeChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum LookupTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl LookupTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::LookupTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MappedTypeClauseChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl MappedTypeClauseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MappedTypeClauseChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MemberExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        Import(Import),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        OptionalChain(OptionalChain),
        ParenthesizedExpression(ParenthesizedExpression),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl MemberExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Import(
                        _,
                    ) => Ok(Self::Import(Import::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::OptionalChain(
                        _,
                    ) => {
                        Ok(
                            Self::OptionalChain(
                                OptionalChain::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MemberExpressionObject {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        Import(Import),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl MemberExpressionObject {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Import(
                        _,
                    ) => Ok(Self::Import(Import::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionObjectRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MemberExpressionProperty {
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
    }
    impl MemberExpressionProperty {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionPropertyRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MemberExpressionPropertyRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MethodDefinitionChildren {
        AccessibilityModifier(AccessibilityModifier),
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        FormalParameters(FormalParameters),
        Number(Number),
        OverrideModifier(OverrideModifier),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        StatementBlock(StatementBlock),
        String(String),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl MethodDefinitionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MethodDefinitionName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl MethodDefinitionName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MethodDefinitionReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl MethodDefinitionReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodDefinitionReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MethodSignatureChildren {
        AccessibilityModifier(AccessibilityModifier),
        AssertsAnnotation(AssertsAnnotation),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        FormalParameters(FormalParameters),
        Number(Number),
        OverrideModifier(OverrideModifier),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
        TypeAnnotation(TypeAnnotation),
        TypeParameters(TypeParameters),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl MethodSignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::FormalParameters(
                        _,
                    ) => {
                        Ok(
                            Self::FormalParameters(
                                FormalParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureChildrenRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MethodSignatureName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl MethodSignatureName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum MethodSignatureReturnType {
        AssertsAnnotation(AssertsAnnotation),
        TypeAnnotation(TypeAnnotation),
        TypePredicateAnnotation(TypePredicateAnnotation),
    }
    impl MethodSignatureReturnType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureReturnTypeRef::AssertsAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::AssertsAnnotation(
                                AssertsAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureReturnTypeRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::MethodSignatureReturnTypeRef::TypePredicateAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicateAnnotation(
                                TypePredicateAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ModuleChildren {
        Comment(Comment),
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
        StatementBlock(StatementBlock),
        String(String),
    }
    impl ModuleChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleChildrenRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ModuleName {
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
        String(String),
    }
    impl ModuleName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleNameRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ModuleNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NamedImportsChildren {
        Comment(Comment),
        ImportSpecifier(ImportSpecifier),
    }
    impl NamedImportsChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamedImportsChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamedImportsChildrenRef::ImportSpecifier(
                        _,
                    ) => {
                        Ok(
                            Self::ImportSpecifier(
                                ImportSpecifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NamespaceExportChildren {
        Comment(Comment),
        Identifier(Identifier),
        String(String),
    }
    impl NamespaceExportChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceExportChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceExportChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceExportChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NamespaceImportChildren {
        Comment(Comment),
        Identifier(Identifier),
    }
    impl NamespaceImportChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceImportChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NamespaceImportChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NestedIdentifierChildren {
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        PropertyIdentifier(PropertyIdentifier),
    }
    impl NestedIdentifierChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifierChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifierChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifierChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifierChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NestedIdentifierObject {
        Identifier(Identifier),
        MemberExpression(MemberExpression),
    }
    impl NestedIdentifierObject {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifierObjectRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedIdentifierObjectRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NestedTypeIdentifierChildren {
        Comment(Comment),
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
        TypeIdentifier(TypeIdentifier),
    }
    impl NestedTypeIdentifierChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifierChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifierChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifierChildrenRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifierChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NestedTypeIdentifierModule {
        Identifier(Identifier),
        NestedIdentifier(NestedIdentifier),
    }
    impl NestedTypeIdentifierModule {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifierModuleRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NestedTypeIdentifierModuleRef::NestedIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedIdentifier(
                                NestedIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NewExpressionChildren {
        Arguments(Arguments),
        Array(Array),
        ArrowFunction(ArrowFunction),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        This(This),
        True(True),
        TypeArguments(TypeArguments),
        Undefined(Undefined),
    }
    impl NewExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Arguments(
                        _,
                    ) => {
                        Ok(
                            Self::Arguments(
                                Arguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::TypeArguments(
                        _,
                    ) => {
                        Ok(
                            Self::TypeArguments(
                                TypeArguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NewExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum NonNullExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl NonNullExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::NonNullExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ObjectAssignmentPatternChildren {
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ObjectAssignmentPatternChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::ShorthandPropertyIdentifierPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ShorthandPropertyIdentifierPattern(
                                ShorthandPropertyIdentifierPattern::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ObjectAssignmentPatternLeft {
        ArrayPattern(ArrayPattern),
        ObjectPattern(ObjectPattern),
        ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern),
    }
    impl ObjectAssignmentPatternLeft {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternLeftRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternLeftRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectAssignmentPatternLeftRef::ShorthandPropertyIdentifierPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ShorthandPropertyIdentifierPattern(
                                ShorthandPropertyIdentifierPattern::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ObjectChildren {
        Comment(Comment),
        MethodDefinition(MethodDefinition),
        Pair(Pair),
        ShorthandPropertyIdentifier(ShorthandPropertyIdentifier),
        SpreadElement(SpreadElement),
    }
    impl ObjectChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectChildrenRef::MethodDefinition(
                        _,
                    ) => {
                        Ok(
                            Self::MethodDefinition(
                                MethodDefinition::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectChildrenRef::Pair(
                        _,
                    ) => Ok(Self::Pair(Pair::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectChildrenRef::ShorthandPropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::ShorthandPropertyIdentifier(
                                ShorthandPropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectChildrenRef::SpreadElement(
                        _,
                    ) => {
                        Ok(
                            Self::SpreadElement(
                                SpreadElement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ObjectPatternChildren {
        Comment(Comment),
        ObjectAssignmentPattern(ObjectAssignmentPattern),
        PairPattern(PairPattern),
        RestPattern(RestPattern),
        ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern),
    }
    impl ObjectPatternChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectPatternChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectPatternChildrenRef::ObjectAssignmentPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectAssignmentPattern(
                                ObjectAssignmentPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectPatternChildrenRef::PairPattern(
                        _,
                    ) => {
                        Ok(
                            Self::PairPattern(
                                PairPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectPatternChildrenRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectPatternChildrenRef::ShorthandPropertyIdentifierPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ShorthandPropertyIdentifierPattern(
                                ShorthandPropertyIdentifierPattern::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ObjectTypeChildren {
        CallSignature(CallSignature),
        Comment(Comment),
        ConstructSignature(ConstructSignature),
        ExportStatement(ExportStatement),
        IndexSignature(IndexSignature),
        MethodSignature(MethodSignature),
        PropertySignature(PropertySignature),
    }
    impl ObjectTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::CallSignature(
                        _,
                    ) => {
                        Ok(
                            Self::CallSignature(
                                CallSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::ConstructSignature(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructSignature(
                                ConstructSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::IndexSignature(
                        _,
                    ) => {
                        Ok(
                            Self::IndexSignature(
                                IndexSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::MethodSignature(
                        _,
                    ) => {
                        Ok(
                            Self::MethodSignature(
                                MethodSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ObjectTypeChildrenRef::PropertySignature(
                        _,
                    ) => {
                        Ok(
                            Self::PropertySignature(
                                PropertySignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum OmittingTypeAnnotationChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl OmittingTypeAnnotationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OmittingTypeAnnotationChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum OptingTypeAnnotationChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl OptingTypeAnnotationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptingTypeAnnotationChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum OptionalParameterChildren {
        AccessibilityModifier(AccessibilityModifier),
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        Decorator(Decorator),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        OverrideModifier(OverrideModifier),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        RestPattern(RestPattern),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAnnotation(TypeAnnotation),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl OptionalParameterChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum OptionalParameterPattern {
        ArrayPattern(ArrayPattern),
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        RestPattern(RestPattern),
        SubscriptExpression(SubscriptExpression),
        This(This),
        Undefined(Undefined),
    }
    impl OptionalParameterPattern {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalParameterPatternRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum OptionalTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl OptionalTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::OptionalTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PairChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl PairChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PairKey {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl PairKey {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairKeyRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairKeyRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairKeyRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairKeyRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairKeyRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PairPatternChildren {
        ArrayPattern(ArrayPattern),
        AssignmentPattern(AssignmentPattern),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        Number(Number),
        ObjectPattern(ObjectPattern),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        RestPattern(RestPattern),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl PairPatternChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::AssignmentPattern(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentPattern(
                                AssignmentPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PairPatternKey {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl PairPatternKey {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternKeyRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternKeyRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternKeyRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternKeyRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternKeyRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PairPatternValue {
        ArrayPattern(ArrayPattern),
        AssignmentPattern(AssignmentPattern),
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        RestPattern(RestPattern),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl PairPatternValue {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::AssignmentPattern(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentPattern(
                                AssignmentPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PairPatternValueRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ParenthesizedExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAnnotation(TypeAnnotation),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ParenthesizedExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ParenthesizedTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ParenthesizedTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ParenthesizedTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ProgramChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        HashBangLine(HashBangLine),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl ProgramChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::HashBangLine(
                        _,
                    ) => {
                        Ok(
                            Self::HashBangLine(
                                HashBangLine::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ProgramChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PropertySignatureChildren {
        AccessibilityModifier(AccessibilityModifier),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        OverrideModifier(OverrideModifier),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
        TypeAnnotation(TypeAnnotation),
    }
    impl PropertySignatureChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PropertySignatureName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl PropertySignatureName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PropertySignatureNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PublicFieldDefinitionChildren {
        AccessibilityModifier(AccessibilityModifier),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        ComputedPropertyName(ComputedPropertyName),
        Decorator(Decorator),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        OverrideModifier(OverrideModifier),
        ParenthesizedExpression(ParenthesizedExpression),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAnnotation(TypeAnnotation),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl PublicFieldDefinitionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PublicFieldDefinitionName {
        ComputedPropertyName(ComputedPropertyName),
        Number(Number),
        PrivatePropertyIdentifier(PrivatePropertyIdentifier),
        PropertyIdentifier(PropertyIdentifier),
        String(String),
    }
    impl PublicFieldDefinitionName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionNameRef::ComputedPropertyName(
                        _,
                    ) => {
                        Ok(
                            Self::ComputedPropertyName(
                                ComputedPropertyName::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionNameRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionNameRef::PrivatePropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PrivatePropertyIdentifier(
                                PrivatePropertyIdentifier::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionNameRef::PropertyIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::PropertyIdentifier(
                                PropertyIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PublicFieldDefinitionNameRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ReadonlyTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl ReadonlyTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReadonlyTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum RegexChildren {
        Comment(Comment),
        RegexFlags(RegexFlags),
        RegexPattern(RegexPattern),
    }
    impl RegexChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RegexChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RegexChildrenRef::RegexFlags(
                        _,
                    ) => {
                        Ok(
                            Self::RegexFlags(
                                RegexFlags::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RegexChildrenRef::RegexPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RegexPattern(
                                RegexPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum RequiredParameterChildren {
        AccessibilityModifier(AccessibilityModifier),
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        Decorator(Decorator),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        OverrideModifier(OverrideModifier),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        RestPattern(RestPattern),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAnnotation(TypeAnnotation),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl RequiredParameterChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::AccessibilityModifier(
                        _,
                    ) => {
                        Ok(
                            Self::AccessibilityModifier(
                                AccessibilityModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Decorator(
                        _,
                    ) => {
                        Ok(
                            Self::Decorator(
                                Decorator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::OverrideModifier(
                        _,
                    ) => {
                        Ok(
                            Self::OverrideModifier(
                                OverrideModifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum RequiredParameterName {
        Identifier(Identifier),
        RestPattern(RestPattern),
    }
    impl RequiredParameterName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterNameRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum RequiredParameterPattern {
        ArrayPattern(ArrayPattern),
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        RestPattern(RestPattern),
        SubscriptExpression(SubscriptExpression),
        This(This),
        Undefined(Undefined),
    }
    impl RequiredParameterPattern {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RequiredParameterPatternRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum RestPatternChildren {
        ArrayPattern(ArrayPattern),
        Comment(Comment),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl RestPatternChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestPatternChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum RestTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl RestTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::RestTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ReturnStatementChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ReturnStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ReturnStatementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SatisfiesExpressionChildren {
        AnonymousConst(AnonymousConst),
        Array(Array),
        ArrayType(ArrayType),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        False(False),
        FlowMaybeType(FlowMaybeType),
        FunctionExpression(FunctionExpression),
        FunctionType(FunctionType),
        GeneratorFunction(GeneratorFunction),
        GenericType(GenericType),
        Identifier(Identifier),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NestedTypeIdentifier(NestedTypeIdentifier),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectType(ObjectType),
        ParenthesizedExpression(ParenthesizedExpression),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateLiteralType(TemplateLiteralType),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        ThisType(ThisType),
        True(True),
        TupleType(TupleType),
        TypeAssertion(TypeAssertion),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UnionType(UnionType),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl SatisfiesExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SatisfiesExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SequenceExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl SequenceExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SequenceExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SpreadElementChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl SpreadElementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SpreadElementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum StatementBlockChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl StatementBlockChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementBlockChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum StringChildren {
        Comment(Comment),
        EscapeSequence(EscapeSequence),
        StringFragment(StringFragment),
    }
    impl StringChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StringChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StringChildrenRef::EscapeSequence(
                        _,
                    ) => {
                        Ok(
                            Self::EscapeSequence(
                                EscapeSequence::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StringChildrenRef::StringFragment(
                        _,
                    ) => {
                        Ok(
                            Self::StringFragment(
                                StringFragment::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SubscriptExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        OptionalChain(OptionalChain),
        ParenthesizedExpression(ParenthesizedExpression),
        PredefinedType(PredefinedType),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl SubscriptExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::OptionalChain(
                        _,
                    ) => {
                        Ok(
                            Self::OptionalChain(
                                OptionalChain::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SubscriptExpressionIndex {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        PredefinedType(PredefinedType),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl SubscriptExpressionIndex {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SubscriptExpressionIndexRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SwitchBodyChildren {
        Comment(Comment),
        SwitchCase(SwitchCase),
        SwitchDefault(SwitchDefault),
    }
    impl SwitchBodyChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchBodyChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchBodyChildrenRef::SwitchCase(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchCase(
                                SwitchCase::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchBodyChildrenRef::SwitchDefault(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchDefault(
                                SwitchDefault::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SwitchCaseChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        BreakStatement(BreakStatement),
        CallExpression(CallExpression),
        Class(Class),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        False(False),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionExpression(FunctionExpression),
        FunctionSignature(FunctionSignature),
        GeneratorFunction(GeneratorFunction),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        Identifier(Identifier),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InstantiationExpression(InstantiationExpression),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        Module(Module),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        ReturnStatement(ReturnStatement),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        StatementBlock(StatementBlock),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        SwitchStatement(SwitchStatement),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        ThrowStatement(ThrowStatement),
        True(True),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
        YieldExpression(YieldExpression),
    }
    impl SwitchCaseChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SwitchCaseValue {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl SwitchCaseValue {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchCaseValueRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SwitchDefaultChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl SwitchDefaultChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchDefaultChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum SwitchStatementChildren {
        Comment(Comment),
        ParenthesizedExpression(ParenthesizedExpression),
        SwitchBody(SwitchBody),
    }
    impl SwitchStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::SwitchStatementChildrenRef::SwitchBody(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchBody(
                                SwitchBody::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TemplateLiteralTypeChildren {
        Comment(Comment),
        StringFragment(StringFragment),
        TemplateType(TemplateType),
    }
    impl TemplateLiteralTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateLiteralTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateLiteralTypeChildrenRef::StringFragment(
                        _,
                    ) => {
                        Ok(
                            Self::StringFragment(
                                StringFragment::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateLiteralTypeChildrenRef::TemplateType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateType(
                                TemplateType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TemplateStringChildren {
        Comment(Comment),
        EscapeSequence(EscapeSequence),
        StringFragment(StringFragment),
        TemplateSubstitution(TemplateSubstitution),
    }
    impl TemplateStringChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateStringChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateStringChildrenRef::EscapeSequence(
                        _,
                    ) => {
                        Ok(
                            Self::EscapeSequence(
                                EscapeSequence::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateStringChildrenRef::StringFragment(
                        _,
                    ) => {
                        Ok(
                            Self::StringFragment(
                                StringFragment::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateStringChildrenRef::TemplateSubstitution(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateSubstitution(
                                TemplateSubstitution::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TemplateSubstitutionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl TemplateSubstitutionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateSubstitutionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TemplateTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl TemplateTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TemplateTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TernaryExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl TernaryExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TernaryExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum ThrowStatementChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        SequenceExpression(SequenceExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl ThrowStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::SequenceExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SequenceExpression(
                                SequenceExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ThrowStatementChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TryStatementChildren {
        CatchClause(CatchClause),
        Comment(Comment),
        FinallyClause(FinallyClause),
        StatementBlock(StatementBlock),
    }
    impl TryStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TryStatementChildrenRef::CatchClause(
                        _,
                    ) => {
                        Ok(
                            Self::CatchClause(
                                CatchClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TryStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TryStatementChildrenRef::FinallyClause(
                        _,
                    ) => {
                        Ok(
                            Self::FinallyClause(
                                FinallyClause::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TryStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TupleTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        OptionalParameter(OptionalParameter),
        OptionalType(OptionalType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        RequiredParameter(RequiredParameter),
        RestType(RestType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl TupleTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::OptionalParameter(
                        _,
                    ) => {
                        Ok(
                            Self::OptionalParameter(
                                OptionalParameter::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::OptionalType(
                        _,
                    ) => {
                        Ok(
                            Self::OptionalType(
                                OptionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::RequiredParameter(
                        _,
                    ) => {
                        Ok(
                            Self::RequiredParameter(
                                RequiredParameter::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::RestType(
                        _,
                    ) => Ok(Self::RestType(RestType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TupleTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeAliasDeclarationChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeParameters(TypeParameters),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl TypeAliasDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::TypeParameters(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameters(
                                TypeParameters::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAliasDeclarationChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeAnnotationChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl TypeAnnotationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAnnotationChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeArgumentsChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl TypeArgumentsChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeArgumentsChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeAssertionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeArguments(TypeArguments),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl TypeAssertionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::TypeArguments(
                        _,
                    ) => {
                        Ok(
                            Self::TypeArguments(
                                TypeArguments::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeAssertionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeParameterChildren {
        Comment(Comment),
        Constraint(Constraint),
        DefaultType(DefaultType),
        TypeIdentifier(TypeIdentifier),
    }
    impl TypeParameterChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParameterChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParameterChildrenRef::Constraint(
                        _,
                    ) => {
                        Ok(
                            Self::Constraint(
                                Constraint::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParameterChildrenRef::DefaultType(
                        _,
                    ) => {
                        Ok(
                            Self::DefaultType(
                                DefaultType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParameterChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeParametersChildren {
        Comment(Comment),
        TypeParameter(TypeParameter),
    }
    impl TypeParametersChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParametersChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeParametersChildrenRef::TypeParameter(
                        _,
                    ) => {
                        Ok(
                            Self::TypeParameter(
                                TypeParameter::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypePredicateAnnotationChildren {
        Comment(Comment),
        TypePredicate(TypePredicate),
    }
    impl TypePredicateAnnotationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateAnnotationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateAnnotationChildrenRef::TypePredicate(
                        _,
                    ) => {
                        Ok(
                            Self::TypePredicate(
                                TypePredicate::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypePredicateChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        Identifier(Identifier),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        This(This),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl TypePredicateChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypePredicateName {
        Identifier(Identifier),
        This(This),
    }
    impl TypePredicateName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypePredicateNameRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum TypeQueryChildren {
        CallExpression(CallExpression),
        Comment(Comment),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        MemberExpression(MemberExpression),
        SubscriptExpression(SubscriptExpression),
        This(This),
    }
    impl TypeQueryChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeQueryChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum UnaryExpressionArgument {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl UnaryExpressionArgument {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionArgumentRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum UnaryExpressionChildren {
        AnonymousBang(AnonymousBang),
        AnonymousDelete(AnonymousDelete),
        AnonymousMinus(AnonymousMinus),
        AnonymousPlus(AnonymousPlus),
        AnonymousTilde(AnonymousTilde),
        AnonymousTypeof(AnonymousTypeof),
        AnonymousVoid(AnonymousVoid),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl UnaryExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousBang(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousBang(
                                AnonymousBang::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousDelete(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousDelete(
                                AnonymousDelete::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinus(
                                AnonymousMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlus(
                                AnonymousPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousTilde(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousTilde(
                                AnonymousTilde::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousTypeof(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousTypeof(
                                AnonymousTypeof::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AnonymousVoid(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousVoid(
                                AnonymousVoid::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum UnaryExpressionOperator {
        AnonymousBang(AnonymousBang),
        AnonymousDelete(AnonymousDelete),
        AnonymousMinus(AnonymousMinus),
        AnonymousPlus(AnonymousPlus),
        AnonymousTilde(AnonymousTilde),
        AnonymousTypeof(AnonymousTypeof),
        AnonymousVoid(AnonymousVoid),
    }
    impl UnaryExpressionOperator {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousBang(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousBang(
                                AnonymousBang::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousDelete(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousDelete(
                                AnonymousDelete::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinus(
                                AnonymousMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlus(
                                AnonymousPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousTilde(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousTilde(
                                AnonymousTilde::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousTypeof(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousTypeof(
                                AnonymousTypeof::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnaryExpressionOperatorRef::AnonymousVoid(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousVoid(
                                AnonymousVoid::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum UnionTypeChildren {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl UnionTypeChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UnionTypeChildrenRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum UpdateExpressionChildren {
        AnonymousMinusMinus(AnonymousMinusMinus),
        AnonymousPlusPlus(AnonymousPlusPlus),
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl UpdateExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::AnonymousMinusMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinusMinus(
                                AnonymousMinusMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::AnonymousPlusPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlusPlus(
                                AnonymousPlusPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum UpdateExpressionOperator {
        AnonymousMinusMinus(AnonymousMinusMinus),
        AnonymousPlusPlus(AnonymousPlusPlus),
    }
    impl UpdateExpressionOperator {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionOperatorRef::AnonymousMinusMinus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousMinusMinus(
                                AnonymousMinusMinus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::UpdateExpressionOperatorRef::AnonymousPlusPlus(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousPlusPlus(
                                AnonymousPlusPlus::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum VariableDeclarationChildren {
        Comment(Comment),
        VariableDeclarator(VariableDeclarator),
    }
    impl VariableDeclarationChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclarationChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclarationChildrenRef::VariableDeclarator(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclarator(
                                VariableDeclarator::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum VariableDeclaratorChildren {
        Array(Array),
        ArrayPattern(ArrayPattern),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ObjectPattern(ObjectPattern),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAnnotation(TypeAnnotation),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl VariableDeclaratorChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::TypeAnnotation(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAnnotation(
                                TypeAnnotation::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum VariableDeclaratorName {
        ArrayPattern(ArrayPattern),
        Identifier(Identifier),
        ObjectPattern(ObjectPattern),
    }
    impl VariableDeclaratorName {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorNameRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorNameRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::VariableDeclaratorNameRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum WhileStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ParenthesizedExpression(ParenthesizedExpression),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl WhileStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WhileStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum WithStatementChildren {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ParenthesizedExpression(ParenthesizedExpression),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl WithStatementChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::WithStatementChildrenRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum YieldExpressionChildren {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl YieldExpressionChildren {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::YieldExpressionChildrenRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum Declaration {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        ClassDeclaration(ClassDeclaration),
        EnumDeclaration(EnumDeclaration),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        ImportAlias(ImportAlias),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
    }
    impl Declaration {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::DeclarationRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum Expression {
        Array(Array),
        ArrowFunction(ArrowFunction),
        AsExpression(AsExpression),
        AssignmentExpression(AssignmentExpression),
        AugmentedAssignmentExpression(AugmentedAssignmentExpression),
        AwaitExpression(AwaitExpression),
        BinaryExpression(BinaryExpression),
        CallExpression(CallExpression),
        Class(Class),
        Comment(Comment),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        InstantiationExpression(InstantiationExpression),
        InternalModule(InternalModule),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NewExpression(NewExpression),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        SatisfiesExpression(SatisfiesExpression),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        TernaryExpression(TernaryExpression),
        This(This),
        True(True),
        TypeAssertion(TypeAssertion),
        UnaryExpression(UnaryExpression),
        Undefined(Undefined),
        UpdateExpression(UpdateExpression),
        YieldExpression(YieldExpression),
    }
    impl Expression {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::AsExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AsExpression(
                                AsExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::AssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AssignmentExpression(
                                AssignmentExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::AugmentedAssignmentExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AugmentedAssignmentExpression(
                                AugmentedAssignmentExpression::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::AwaitExpression(
                        _,
                    ) => {
                        Ok(
                            Self::AwaitExpression(
                                AwaitExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::BinaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::BinaryExpression(
                                BinaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::InstantiationExpression(
                        _,
                    ) => {
                        Ok(
                            Self::InstantiationExpression(
                                InstantiationExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::NewExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NewExpression(
                                NewExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::SatisfiesExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SatisfiesExpression(
                                SatisfiesExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::TernaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::TernaryExpression(
                                TernaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::TypeAssertion(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAssertion(
                                TypeAssertion::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::UnaryExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UnaryExpression(
                                UnaryExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::UpdateExpression(
                        _,
                    ) => {
                        Ok(
                            Self::UpdateExpression(
                                UpdateExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::ExpressionRef::YieldExpression(
                        _,
                    ) => {
                        Ok(
                            Self::YieldExpression(
                                YieldExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum Pattern {
        ArrayPattern(ArrayPattern),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        NonNullExpression(NonNullExpression),
        ObjectPattern(ObjectPattern),
        RestPattern(RestPattern),
        SubscriptExpression(SubscriptExpression),
        Undefined(Undefined),
    }
    impl Pattern {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::ArrayPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayPattern(
                                ArrayPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::ObjectPattern(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectPattern(
                                ObjectPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::RestPattern(
                        _,
                    ) => {
                        Ok(
                            Self::RestPattern(
                                RestPattern::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PatternRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PrimaryExpression {
        Array(Array),
        ArrowFunction(ArrowFunction),
        CallExpression(CallExpression),
        Class(Class),
        False(False),
        FunctionExpression(FunctionExpression),
        GeneratorFunction(GeneratorFunction),
        Identifier(Identifier),
        MemberExpression(MemberExpression),
        MetaProperty(MetaProperty),
        NonNullExpression(NonNullExpression),
        Null(Null),
        Number(Number),
        Object(Object),
        ParenthesizedExpression(ParenthesizedExpression),
        Regex(Regex),
        String(String),
        SubscriptExpression(SubscriptExpression),
        Super(Super),
        TemplateString(TemplateString),
        This(This),
        True(True),
        Undefined(Undefined),
    }
    impl PrimaryExpression {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Array(
                        _,
                    ) => Ok(Self::Array(Array::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::ArrowFunction(
                        _,
                    ) => {
                        Ok(
                            Self::ArrowFunction(
                                ArrowFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Class(
                        _,
                    ) => Ok(Self::Class(Class::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::False(
                        _,
                    ) => Ok(Self::False(False::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::FunctionExpression(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionExpression(
                                FunctionExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::GeneratorFunction(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunction(
                                GeneratorFunction::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Identifier(
                        _,
                    ) => {
                        Ok(
                            Self::Identifier(
                                Identifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::MetaProperty(
                        _,
                    ) => {
                        Ok(
                            Self::MetaProperty(
                                MetaProperty::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::NonNullExpression(
                        _,
                    ) => {
                        Ok(
                            Self::NonNullExpression(
                                NonNullExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Null(
                        _,
                    ) => Ok(Self::Null(Null::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Number(
                        _,
                    ) => Ok(Self::Number(Number::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Object(
                        _,
                    ) => Ok(Self::Object(Object::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::ParenthesizedExpression(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedExpression(
                                ParenthesizedExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Regex(
                        _,
                    ) => Ok(Self::Regex(Regex::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::String(
                        _,
                    ) => Ok(Self::String(String::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::SubscriptExpression(
                        _,
                    ) => {
                        Ok(
                            Self::SubscriptExpression(
                                SubscriptExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Super(
                        _,
                    ) => Ok(Self::Super(Super::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::TemplateString(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateString(
                                TemplateString::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::This(
                        _,
                    ) => Ok(Self::This(This::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::True(
                        _,
                    ) => Ok(Self::True(True::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryExpressionRef::Undefined(
                        _,
                    ) => {
                        Ok(
                            Self::Undefined(
                                Undefined::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum PrimaryType {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        ConditionalType(ConditionalType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl PrimaryType {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::PrimaryTypeRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum Statement {
        AbstractClassDeclaration(AbstractClassDeclaration),
        AmbientDeclaration(AmbientDeclaration),
        BreakStatement(BreakStatement),
        ClassDeclaration(ClassDeclaration),
        Comment(Comment),
        ContinueStatement(ContinueStatement),
        DebuggerStatement(DebuggerStatement),
        DoStatement(DoStatement),
        EmptyStatement(EmptyStatement),
        EnumDeclaration(EnumDeclaration),
        ExportStatement(ExportStatement),
        ExpressionStatement(ExpressionStatement),
        ForInStatement(ForInStatement),
        ForStatement(ForStatement),
        FunctionDeclaration(FunctionDeclaration),
        FunctionSignature(FunctionSignature),
        GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
        IfStatement(IfStatement),
        ImportAlias(ImportAlias),
        ImportStatement(ImportStatement),
        InterfaceDeclaration(InterfaceDeclaration),
        InternalModule(InternalModule),
        LabeledStatement(LabeledStatement),
        LexicalDeclaration(LexicalDeclaration),
        Module(Module),
        ReturnStatement(ReturnStatement),
        StatementBlock(StatementBlock),
        SwitchStatement(SwitchStatement),
        ThrowStatement(ThrowStatement),
        TryStatement(TryStatement),
        TypeAliasDeclaration(TypeAliasDeclaration),
        VariableDeclaration(VariableDeclaration),
        WhileStatement(WhileStatement),
        WithStatement(WithStatement),
    }
    impl Statement {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::AbstractClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AbstractClassDeclaration(
                                AbstractClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::AmbientDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::AmbientDeclaration(
                                AmbientDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::BreakStatement(
                        _,
                    ) => {
                        Ok(
                            Self::BreakStatement(
                                BreakStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ClassDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::ClassDeclaration(
                                ClassDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ContinueStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ContinueStatement(
                                ContinueStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::DebuggerStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DebuggerStatement(
                                DebuggerStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::DoStatement(
                        _,
                    ) => {
                        Ok(
                            Self::DoStatement(
                                DoStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::EmptyStatement(
                        _,
                    ) => {
                        Ok(
                            Self::EmptyStatement(
                                EmptyStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::EnumDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::EnumDeclaration(
                                EnumDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ExportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExportStatement(
                                ExportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ExpressionStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ExpressionStatement(
                                ExpressionStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ForInStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForInStatement(
                                ForInStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ForStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ForStatement(
                                ForStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::FunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionDeclaration(
                                FunctionDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::FunctionSignature(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionSignature(
                                FunctionSignature::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::GeneratorFunctionDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::GeneratorFunctionDeclaration(
                                GeneratorFunctionDeclaration::new(
                                    py,
                                    id,
                                    codebase_arc.clone(),
                                )?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::IfStatement(
                        _,
                    ) => {
                        Ok(
                            Self::IfStatement(
                                IfStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ImportAlias(
                        _,
                    ) => {
                        Ok(
                            Self::ImportAlias(
                                ImportAlias::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ImportStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ImportStatement(
                                ImportStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::InterfaceDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::InterfaceDeclaration(
                                InterfaceDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::InternalModule(
                        _,
                    ) => {
                        Ok(
                            Self::InternalModule(
                                InternalModule::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::LabeledStatement(
                        _,
                    ) => {
                        Ok(
                            Self::LabeledStatement(
                                LabeledStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::LexicalDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::LexicalDeclaration(
                                LexicalDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::Module(
                        _,
                    ) => Ok(Self::Module(Module::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ReturnStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ReturnStatement(
                                ReturnStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::StatementBlock(
                        _,
                    ) => {
                        Ok(
                            Self::StatementBlock(
                                StatementBlock::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::SwitchStatement(
                        _,
                    ) => {
                        Ok(
                            Self::SwitchStatement(
                                SwitchStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::ThrowStatement(
                        _,
                    ) => {
                        Ok(
                            Self::ThrowStatement(
                                ThrowStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::TryStatement(
                        _,
                    ) => {
                        Ok(
                            Self::TryStatement(
                                TryStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::TypeAliasDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::TypeAliasDeclaration(
                                TypeAliasDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::VariableDeclaration(
                        _,
                    ) => {
                        Ok(
                            Self::VariableDeclaration(
                                VariableDeclaration::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::WhileStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WhileStatement(
                                WhileStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::StatementRef::WithStatement(
                        _,
                    ) => {
                        Ok(
                            Self::WithStatement(
                                WithStatement::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    #[derive(IntoPyObject)]
    pub enum Type {
        AnonymousConst(AnonymousConst),
        ArrayType(ArrayType),
        CallExpression(CallExpression),
        Comment(Comment),
        ConditionalType(ConditionalType),
        ConstructorType(ConstructorType),
        ExistentialType(ExistentialType),
        FlowMaybeType(FlowMaybeType),
        FunctionType(FunctionType),
        GenericType(GenericType),
        IndexTypeQuery(IndexTypeQuery),
        InferType(InferType),
        IntersectionType(IntersectionType),
        LiteralType(LiteralType),
        LookupType(LookupType),
        MemberExpression(MemberExpression),
        NestedTypeIdentifier(NestedTypeIdentifier),
        ObjectType(ObjectType),
        ParenthesizedType(ParenthesizedType),
        PredefinedType(PredefinedType),
        ReadonlyType(ReadonlyType),
        TemplateLiteralType(TemplateLiteralType),
        ThisType(ThisType),
        TupleType(TupleType),
        TypeIdentifier(TypeIdentifier),
        TypeQuery(TypeQuery),
        UnionType(UnionType),
    }
    impl Type {
        pub fn new(
            py: Python<'_>,
            id: codegen_sdk_common::CSTNodeTreeId,
            codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
        ) -> PyResult<Self> {
            let codebase = codebase_arc.get(py);
            let path = id.file(codebase.db());
            let file = codebase.get_file_for_id(path);
            let file = match file {
                Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
                _ => {
                    return Err(
                        pyo3::exceptions::PyValueError::new_err(
                            format!(
                                "File not found for path: {}", path.path(codebase.db())
                                .display()
                            ),
                        ),
                    );
                }
            };
            let node = file.tree(codebase.db()).get(id.id(codebase.db()));
            if let Some(node) = node {
                match node.as_ref().try_into().unwrap() {
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::AnonymousConst(
                        _,
                    ) => {
                        Ok(
                            Self::AnonymousConst(
                                AnonymousConst::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ArrayType(
                        _,
                    ) => {
                        Ok(
                            Self::ArrayType(
                                ArrayType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::CallExpression(
                        _,
                    ) => {
                        Ok(
                            Self::CallExpression(
                                CallExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::Comment(
                        _,
                    ) => Ok(Self::Comment(Comment::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ConditionalType(
                        _,
                    ) => {
                        Ok(
                            Self::ConditionalType(
                                ConditionalType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ConstructorType(
                        _,
                    ) => {
                        Ok(
                            Self::ConstructorType(
                                ConstructorType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ExistentialType(
                        _,
                    ) => {
                        Ok(
                            Self::ExistentialType(
                                ExistentialType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::FlowMaybeType(
                        _,
                    ) => {
                        Ok(
                            Self::FlowMaybeType(
                                FlowMaybeType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::FunctionType(
                        _,
                    ) => {
                        Ok(
                            Self::FunctionType(
                                FunctionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::GenericType(
                        _,
                    ) => {
                        Ok(
                            Self::GenericType(
                                GenericType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::IndexTypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::IndexTypeQuery(
                                IndexTypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::InferType(
                        _,
                    ) => {
                        Ok(
                            Self::InferType(
                                InferType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::IntersectionType(
                        _,
                    ) => {
                        Ok(
                            Self::IntersectionType(
                                IntersectionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::LiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::LiteralType(
                                LiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::LookupType(
                        _,
                    ) => {
                        Ok(
                            Self::LookupType(
                                LookupType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::MemberExpression(
                        _,
                    ) => {
                        Ok(
                            Self::MemberExpression(
                                MemberExpression::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::NestedTypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::NestedTypeIdentifier(
                                NestedTypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ObjectType(
                        _,
                    ) => {
                        Ok(
                            Self::ObjectType(
                                ObjectType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ParenthesizedType(
                        _,
                    ) => {
                        Ok(
                            Self::ParenthesizedType(
                                ParenthesizedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::PredefinedType(
                        _,
                    ) => {
                        Ok(
                            Self::PredefinedType(
                                PredefinedType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ReadonlyType(
                        _,
                    ) => {
                        Ok(
                            Self::ReadonlyType(
                                ReadonlyType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::TemplateLiteralType(
                        _,
                    ) => {
                        Ok(
                            Self::TemplateLiteralType(
                                TemplateLiteralType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::ThisType(
                        _,
                    ) => Ok(Self::ThisType(ThisType::new(py, id, codebase_arc.clone())?)),
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::TupleType(
                        _,
                    ) => {
                        Ok(
                            Self::TupleType(
                                TupleType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::TypeIdentifier(
                        _,
                    ) => {
                        Ok(
                            Self::TypeIdentifier(
                                TypeIdentifier::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::TypeQuery(
                        _,
                    ) => {
                        Ok(
                            Self::TypeQuery(
                                TypeQuery::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                    codegen_sdk_analyzer::codegen_sdk_typescript::cst::TypeRef::UnionType(
                        _,
                    ) => {
                        Ok(
                            Self::UnionType(
                                UnionType::new(py, id, codebase_arc.clone())?,
                            ),
                        )
                    }
                }
            } else {
                Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
            }
        }
    }
    pub fn register_cst(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
        let child_module = PyModule::new(parent_module.py(), "cst")?;
        child_module.add_class::<AbstractClassDeclaration>()?;
        child_module.add_class::<AbstractMethodSignature>()?;
        child_module.add_class::<AccessibilityModifier>()?;
        child_module.add_class::<AddingTypeAnnotation>()?;
        child_module.add_class::<AmbientDeclaration>()?;
        child_module.add_class::<AnonymousAbstract>()?;
        child_module.add_class::<AnonymousAccessor>()?;
        child_module.add_class::<AnonymousAmpersand>()?;
        child_module.add_class::<AnonymousAmpersandAmpersand>()?;
        child_module.add_class::<AnonymousAmpersandAmpersandEquals>()?;
        child_module.add_class::<AnonymousAmpersandEquals>()?;
        child_module.add_class::<AnonymousAny>()?;
        child_module.add_class::<AnonymousAs>()?;
        child_module.add_class::<AnonymousAssert>()?;
        child_module.add_class::<AnonymousAsserts>()?;
        child_module.add_class::<AnonymousAsterisk>()?;
        child_module.add_class::<AnonymousAsteriskAsterisk>()?;
        child_module.add_class::<AnonymousAsteriskAsteriskEquals>()?;
        child_module.add_class::<AnonymousAsteriskEquals>()?;
        child_module.add_class::<AnonymousAsync>()?;
        child_module.add_class::<AnonymousAt>()?;
        child_module.add_class::<AnonymousAwait>()?;
        child_module.add_class::<AnonymousBacktick>()?;
        child_module.add_class::<AnonymousBang>()?;
        child_module.add_class::<AnonymousBangEquals>()?;
        child_module.add_class::<AnonymousBangEqualsEquals>()?;
        child_module.add_class::<AnonymousBoolean>()?;
        child_module.add_class::<AnonymousBreak>()?;
        child_module.add_class::<AnonymousCaret>()?;
        child_module.add_class::<AnonymousCaretEquals>()?;
        child_module.add_class::<AnonymousCase>()?;
        child_module.add_class::<AnonymousCatch>()?;
        child_module.add_class::<AnonymousClass>()?;
        child_module.add_class::<AnonymousCloseBrace>()?;
        child_module.add_class::<AnonymousCloseBracket>()?;
        child_module.add_class::<AnonymousCloseParen>()?;
        child_module.add_class::<AnonymousColon>()?;
        child_module.add_class::<AnonymousComma>()?;
        child_module.add_class::<AnonymousConst>()?;
        child_module.add_class::<AnonymousContinue>()?;
        child_module.add_class::<AnonymousDebugger>()?;
        child_module.add_class::<AnonymousDeclare>()?;
        child_module.add_class::<AnonymousDefault>()?;
        child_module.add_class::<AnonymousDelete>()?;
        child_module.add_class::<AnonymousDo>()?;
        child_module.add_class::<AnonymousDollarOpenBrace>()?;
        child_module.add_class::<AnonymousDot>()?;
        child_module.add_class::<AnonymousDotDotDot>()?;
        child_module.add_class::<AnonymousDoubleQuote>()?;
        child_module.add_class::<AnonymousElse>()?;
        child_module.add_class::<AnonymousEnum>()?;
        child_module.add_class::<AnonymousEquals>()?;
        child_module.add_class::<AnonymousEqualsEquals>()?;
        child_module.add_class::<AnonymousEqualsEqualsEquals>()?;
        child_module.add_class::<AnonymousEqualsGreaterThan>()?;
        child_module.add_class::<AnonymousExport>()?;
        child_module.add_class::<AnonymousExtends>()?;
        child_module.add_class::<AnonymousFinally>()?;
        child_module.add_class::<AnonymousFor>()?;
        child_module.add_class::<AnonymousFrom>()?;
        child_module.add_class::<AnonymousFunction>()?;
        child_module.add_class::<AnonymousGet>()?;
        child_module.add_class::<AnonymousGlobal>()?;
        child_module.add_class::<AnonymousGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanEquals>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanEquals>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanGreaterThan>()?;
        child_module.add_class::<AnonymousGreaterThanGreaterThanGreaterThanEquals>()?;
        child_module.add_class::<AnonymousIf>()?;
        child_module.add_class::<AnonymousImplements>()?;
        child_module.add_class::<AnonymousImport>()?;
        child_module.add_class::<AnonymousIn>()?;
        child_module.add_class::<AnonymousInfer>()?;
        child_module.add_class::<AnonymousInstanceof>()?;
        child_module.add_class::<AnonymousInterface>()?;
        child_module.add_class::<AnonymousIs>()?;
        child_module.add_class::<AnonymousKeyof>()?;
        child_module.add_class::<AnonymousLessThan>()?;
        child_module.add_class::<AnonymousLessThanEquals>()?;
        child_module.add_class::<AnonymousLessThanLessThan>()?;
        child_module.add_class::<AnonymousLessThanLessThanEquals>()?;
        child_module.add_class::<AnonymousLet>()?;
        child_module.add_class::<AnonymousMeta>()?;
        child_module.add_class::<AnonymousMinus>()?;
        child_module.add_class::<AnonymousMinusEquals>()?;
        child_module.add_class::<AnonymousMinusMinus>()?;
        child_module.add_class::<AnonymousMinusQuestionMarkColon>()?;
        child_module.add_class::<AnonymousModule>()?;
        child_module.add_class::<AnonymousNamespace>()?;
        child_module.add_class::<AnonymousNever>()?;
        child_module.add_class::<AnonymousNew>()?;
        child_module.add_class::<AnonymousNumber>()?;
        child_module.add_class::<AnonymousObject>()?;
        child_module.add_class::<AnonymousOf>()?;
        child_module.add_class::<AnonymousOpenBrace>()?;
        child_module.add_class::<AnonymousOpenBracePipe>()?;
        child_module.add_class::<AnonymousOpenBracket>()?;
        child_module.add_class::<AnonymousOpenParen>()?;
        child_module.add_class::<AnonymousOverride>()?;
        child_module.add_class::<AnonymousPercent>()?;
        child_module.add_class::<AnonymousPercentEquals>()?;
        child_module.add_class::<AnonymousPipe>()?;
        child_module.add_class::<AnonymousPipeCloseBrace>()?;
        child_module.add_class::<AnonymousPipeEquals>()?;
        child_module.add_class::<AnonymousPipePipe>()?;
        child_module.add_class::<AnonymousPipePipeEquals>()?;
        child_module.add_class::<AnonymousPlus>()?;
        child_module.add_class::<AnonymousPlusEquals>()?;
        child_module.add_class::<AnonymousPlusPlus>()?;
        child_module.add_class::<AnonymousPlusQuestionMarkColon>()?;
        child_module.add_class::<AnonymousPrivate>()?;
        child_module.add_class::<AnonymousProtected>()?;
        child_module.add_class::<AnonymousPublic>()?;
        child_module.add_class::<AnonymousQuestionMark>()?;
        child_module.add_class::<AnonymousQuestionMarkColon>()?;
        child_module.add_class::<AnonymousQuestionMarkDot>()?;
        child_module.add_class::<AnonymousQuestionMarkQuestionMark>()?;
        child_module.add_class::<AnonymousQuestionMarkQuestionMarkEquals>()?;
        child_module.add_class::<AnonymousReadonly>()?;
        child_module.add_class::<AnonymousRequire>()?;
        child_module.add_class::<AnonymousReturn>()?;
        child_module.add_class::<AnonymousSatisfies>()?;
        child_module.add_class::<AnonymousSemicolon>()?;
        child_module.add_class::<AnonymousSet>()?;
        child_module.add_class::<AnonymousSingleQuote>()?;
        child_module.add_class::<AnonymousSlash>()?;
        child_module.add_class::<AnonymousSlashEquals>()?;
        child_module.add_class::<AnonymousStatic>()?;
        child_module.add_class::<AnonymousString>()?;
        child_module.add_class::<AnonymousSwitch>()?;
        child_module.add_class::<AnonymousSymbol>()?;
        child_module.add_class::<AnonymousTarget>()?;
        child_module.add_class::<AnonymousThrow>()?;
        child_module.add_class::<AnonymousTilde>()?;
        child_module.add_class::<AnonymousTry>()?;
        child_module.add_class::<AnonymousType>()?;
        child_module.add_class::<AnonymousTypeof>()?;
        child_module.add_class::<AnonymousUniqueSymbol>()?;
        child_module.add_class::<AnonymousUnknown>()?;
        child_module.add_class::<AnonymousUsing>()?;
        child_module.add_class::<AnonymousVar>()?;
        child_module.add_class::<AnonymousVoid>()?;
        child_module.add_class::<AnonymousWhile>()?;
        child_module.add_class::<AnonymousWith>()?;
        child_module.add_class::<AnonymousYield>()?;
        child_module.add_class::<Arguments>()?;
        child_module.add_class::<Array>()?;
        child_module.add_class::<ArrayPattern>()?;
        child_module.add_class::<ArrayType>()?;
        child_module.add_class::<ArrowFunction>()?;
        child_module.add_class::<AsExpression>()?;
        child_module.add_class::<Asserts>()?;
        child_module.add_class::<AssertsAnnotation>()?;
        child_module.add_class::<AssignmentExpression>()?;
        child_module.add_class::<AssignmentPattern>()?;
        child_module.add_class::<AugmentedAssignmentExpression>()?;
        child_module.add_class::<AwaitExpression>()?;
        child_module.add_class::<BinaryExpression>()?;
        child_module.add_class::<BreakStatement>()?;
        child_module.add_class::<CallExpression>()?;
        child_module.add_class::<CallSignature>()?;
        child_module.add_class::<CatchClause>()?;
        child_module.add_class::<Class>()?;
        child_module.add_class::<ClassBody>()?;
        child_module.add_class::<ClassDeclaration>()?;
        child_module.add_class::<ClassHeritage>()?;
        child_module.add_class::<ClassStaticBlock>()?;
        child_module.add_class::<Comment>()?;
        child_module.add_class::<ComputedPropertyName>()?;
        child_module.add_class::<ConditionalType>()?;
        child_module.add_class::<Constraint>()?;
        child_module.add_class::<ConstructSignature>()?;
        child_module.add_class::<ConstructorType>()?;
        child_module.add_class::<ContinueStatement>()?;
        child_module.add_class::<DebuggerStatement>()?;
        child_module.add_class::<Decorator>()?;
        child_module.add_class::<DefaultType>()?;
        child_module.add_class::<DoStatement>()?;
        child_module.add_class::<ElseClause>()?;
        child_module.add_class::<EmptyStatement>()?;
        child_module.add_class::<EnumAssignment>()?;
        child_module.add_class::<EnumBody>()?;
        child_module.add_class::<EnumDeclaration>()?;
        child_module.add_class::<EscapeSequence>()?;
        child_module.add_class::<ExistentialType>()?;
        child_module.add_class::<ExportClause>()?;
        child_module.add_class::<ExportSpecifier>()?;
        child_module.add_class::<ExportStatement>()?;
        child_module.add_class::<ExpressionStatement>()?;
        child_module.add_class::<ExtendsClause>()?;
        child_module.add_class::<ExtendsTypeClause>()?;
        child_module.add_class::<False>()?;
        child_module.add_class::<FinallyClause>()?;
        child_module.add_class::<FlowMaybeType>()?;
        child_module.add_class::<ForInStatement>()?;
        child_module.add_class::<ForStatement>()?;
        child_module.add_class::<FormalParameters>()?;
        child_module.add_class::<FunctionDeclaration>()?;
        child_module.add_class::<FunctionExpression>()?;
        child_module.add_class::<FunctionSignature>()?;
        child_module.add_class::<FunctionType>()?;
        child_module.add_class::<GeneratorFunction>()?;
        child_module.add_class::<GeneratorFunctionDeclaration>()?;
        child_module.add_class::<GenericType>()?;
        child_module.add_class::<HashBangLine>()?;
        child_module.add_class::<HtmlComment>()?;
        child_module.add_class::<Identifier>()?;
        child_module.add_class::<IfStatement>()?;
        child_module.add_class::<ImplementsClause>()?;
        child_module.add_class::<Import>()?;
        child_module.add_class::<ImportAlias>()?;
        child_module.add_class::<ImportAttribute>()?;
        child_module.add_class::<ImportClause>()?;
        child_module.add_class::<ImportRequireClause>()?;
        child_module.add_class::<ImportSpecifier>()?;
        child_module.add_class::<ImportStatement>()?;
        child_module.add_class::<IndexSignature>()?;
        child_module.add_class::<IndexTypeQuery>()?;
        child_module.add_class::<InferType>()?;
        child_module.add_class::<InstantiationExpression>()?;
        child_module.add_class::<InterfaceBody>()?;
        child_module.add_class::<InterfaceDeclaration>()?;
        child_module.add_class::<InternalModule>()?;
        child_module.add_class::<IntersectionType>()?;
        child_module.add_class::<LabeledStatement>()?;
        child_module.add_class::<LexicalDeclaration>()?;
        child_module.add_class::<LiteralType>()?;
        child_module.add_class::<LookupType>()?;
        child_module.add_class::<MappedTypeClause>()?;
        child_module.add_class::<MemberExpression>()?;
        child_module.add_class::<MetaProperty>()?;
        child_module.add_class::<MethodDefinition>()?;
        child_module.add_class::<MethodSignature>()?;
        child_module.add_class::<Module>()?;
        child_module.add_class::<NamedImports>()?;
        child_module.add_class::<NamespaceExport>()?;
        child_module.add_class::<NamespaceImport>()?;
        child_module.add_class::<NestedIdentifier>()?;
        child_module.add_class::<NestedTypeIdentifier>()?;
        child_module.add_class::<NewExpression>()?;
        child_module.add_class::<NonNullExpression>()?;
        child_module.add_class::<Null>()?;
        child_module.add_class::<Number>()?;
        child_module.add_class::<Object>()?;
        child_module.add_class::<ObjectAssignmentPattern>()?;
        child_module.add_class::<ObjectPattern>()?;
        child_module.add_class::<ObjectType>()?;
        child_module.add_class::<OmittingTypeAnnotation>()?;
        child_module.add_class::<OptingTypeAnnotation>()?;
        child_module.add_class::<OptionalChain>()?;
        child_module.add_class::<OptionalParameter>()?;
        child_module.add_class::<OptionalType>()?;
        child_module.add_class::<OverrideModifier>()?;
        child_module.add_class::<Pair>()?;
        child_module.add_class::<PairPattern>()?;
        child_module.add_class::<ParenthesizedExpression>()?;
        child_module.add_class::<ParenthesizedType>()?;
        child_module.add_class::<PredefinedType>()?;
        child_module.add_class::<PrivatePropertyIdentifier>()?;
        child_module.add_class::<Program>()?;
        child_module.add_class::<PropertyIdentifier>()?;
        child_module.add_class::<PropertySignature>()?;
        child_module.add_class::<PublicFieldDefinition>()?;
        child_module.add_class::<ReadonlyType>()?;
        child_module.add_class::<Regex>()?;
        child_module.add_class::<RegexFlags>()?;
        child_module.add_class::<RegexPattern>()?;
        child_module.add_class::<RequiredParameter>()?;
        child_module.add_class::<RestPattern>()?;
        child_module.add_class::<RestType>()?;
        child_module.add_class::<ReturnStatement>()?;
        child_module.add_class::<SatisfiesExpression>()?;
        child_module.add_class::<SequenceExpression>()?;
        child_module.add_class::<ShorthandPropertyIdentifier>()?;
        child_module.add_class::<ShorthandPropertyIdentifierPattern>()?;
        child_module.add_class::<SpreadElement>()?;
        child_module.add_class::<StatementBlock>()?;
        child_module.add_class::<StatementIdentifier>()?;
        child_module.add_class::<String>()?;
        child_module.add_class::<StringFragment>()?;
        child_module.add_class::<SubscriptExpression>()?;
        child_module.add_class::<Super>()?;
        child_module.add_class::<SwitchBody>()?;
        child_module.add_class::<SwitchCase>()?;
        child_module.add_class::<SwitchDefault>()?;
        child_module.add_class::<SwitchStatement>()?;
        child_module.add_class::<TemplateLiteralType>()?;
        child_module.add_class::<TemplateString>()?;
        child_module.add_class::<TemplateSubstitution>()?;
        child_module.add_class::<TemplateType>()?;
        child_module.add_class::<TernaryExpression>()?;
        child_module.add_class::<This>()?;
        child_module.add_class::<ThisType>()?;
        child_module.add_class::<ThrowStatement>()?;
        child_module.add_class::<True>()?;
        child_module.add_class::<TryStatement>()?;
        child_module.add_class::<TupleType>()?;
        child_module.add_class::<TypeAliasDeclaration>()?;
        child_module.add_class::<TypeAnnotation>()?;
        child_module.add_class::<TypeArguments>()?;
        child_module.add_class::<TypeAssertion>()?;
        child_module.add_class::<TypeIdentifier>()?;
        child_module.add_class::<TypeParameter>()?;
        child_module.add_class::<TypeParameters>()?;
        child_module.add_class::<TypePredicate>()?;
        child_module.add_class::<TypePredicateAnnotation>()?;
        child_module.add_class::<TypeQuery>()?;
        child_module.add_class::<UnaryExpression>()?;
        child_module.add_class::<Undefined>()?;
        child_module.add_class::<UnionType>()?;
        child_module.add_class::<UpdateExpression>()?;
        child_module.add_class::<VariableDeclaration>()?;
        child_module.add_class::<VariableDeclarator>()?;
        child_module.add_class::<WhileStatement>()?;
        child_module.add_class::<WithStatement>()?;
        child_module.add_class::<YieldExpression>()?;
        parent_module.add_submodule(&child_module)?;
        Ok(())
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct Class {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Class {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::Class<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .classes(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Class {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::AbstractClassDeclaration> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::AbstractClassDeclaration::new(
                py,
                node.node_id(db),
                self.codebase.clone(),
            )?,
        )
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::TypeIdentifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::TypeIdentifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct Function {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Function {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<
        &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::Function<'db>,
    > {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .functions(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Function {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::FunctionSignature> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::FunctionSignature::new(py, node.node_id(db), self.codebase.clone())?)
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::Identifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::Identifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct Interface {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Interface {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<
        &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::Interface<'db>,
    > {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .interfaces(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Interface {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::InterfaceDeclaration> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::InterfaceDeclaration::new(py, node.node_id(db), self.codebase.clone())?)
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::TypeIdentifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::TypeIdentifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct Method {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Method {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::Method<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .methods(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Method {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::AbstractMethodSignature> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::AbstractMethodSignature::new(
                py,
                node.node_id(db),
                self.codebase.clone(),
            )?,
        )
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::PropertyIdentifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::PropertyIdentifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct Module {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl Module {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::Module<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .definitions(codebase.db())
            .modules(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl Module {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::Module> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::Module::new(py, node.node_id(db), self.codebase.clone())?)
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::Identifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::Identifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct ClassRef {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl ClassRef {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<
        &'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::ClassRef<'db>,
    > {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .references(codebase.db())
            .classes(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl ClassRef {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::NewExpression> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::NewExpression::new(py, node.node_id(db), self.codebase.clone())?)
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::Identifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::Identifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub struct TypeRef {
    id: codegen_sdk_resolution::FullyQualifiedName,
    idx: usize,
    codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
}
impl TypeRef {
    pub fn new(
        id: codegen_sdk_resolution::FullyQualifiedName,
        idx: usize,
        codebase: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> Self {
        Self { id, idx, codebase }
    }
    fn get<'db>(
        &'db self,
        py: Python<'db>,
    ) -> PyResult<&'db codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypeRef<'db>> {
        let codebase = self.codebase.get(py);
        let path = self.id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let name = self.id.name(codebase.db());
        let node = file
            .references(codebase.db())
            .types(codebase.db())
            .get(name)
            .unwrap();
        node.get(self.idx)
            .ok_or(pyo3::exceptions::PyValueError::new_err("Index out of bounds"))
    }
}
#[pymethods]
impl TypeRef {
    pub fn ts_node(&self, py: Python<'_>) -> PyResult<cst::TypeAnnotation> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(cst::TypeAnnotation::new(py, node.node_id(db), self.codebase.clone())?)
    }
    fn source(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let db = self.codebase.get(py).db();
        let node = self.get(py)?.node(db);
        Ok(node.source())
    }
    fn __str__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        Ok(self.source(py)?)
    }
    fn __repr__(&self, py: Python<'_>) -> PyResult<std::string::String> {
        let node = self.get(py)?;
        let codebase = self.codebase.get(py);
        codebase.attach(|_db| { Ok(format!("{node:#?}")) })
    }
    #[getter]
    pub fn name(&self, py: Python<'_>) -> PyResult<cst::TypeIdentifier> {
        let node = self.get(py)?;
        let db = self.codebase.get(py).db();
        Ok(
            cst::TypeIdentifier::new(
                py.clone(),
                node._name(db).clone(),
                self.codebase.clone(),
            )?,
        )
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub enum Symbol {
    Class(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Class),
    Function(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Function),
    Interface(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Interface),
    Method(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Method),
    Module(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Module),
    ClassRef(codegen_sdk_analyzer::codegen_sdk_typescript::ast::ClassRef),
    TypeRef(codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypeRef),
}
impl Symbol {
    pub fn new(
        py: Python<'_>,
        id: codegen_sdk_common::FullyQualifiedName,
        codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> PyResult<Self> {
        let codebase = codebase_arc.get(py);
        let path = id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let node = file.tree(codebase.db()).get(id.id(codebase.db()));
        if let Some(node) = node {
            match node.as_ref().try_into().unwrap() {
                Class => Ok(Self::Class(Class::new(py, id, codebase_arc))),
                Function => Ok(Self::Function(Function::new(py, id, codebase_arc))),
                Interface => Ok(Self::Interface(Interface::new(py, id, codebase_arc))),
                Method => Ok(Self::Method(Method::new(py, id, codebase_arc))),
                Module => Ok(Self::Module(Module::new(py, id, codebase_arc))),
                ClassRef => Ok(Self::ClassRef(ClassRef::new(py, id, codebase_arc))),
                TypeRef => Ok(Self::TypeRef(TypeRef::new(py, id, codebase_arc))),
            }
        } else {
            Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
        }
    }
}
#[pyclass(module = "codegen_sdk_pink.typescript")]
pub enum Reference {
    Class(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Class),
    Function(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Function),
    Interface(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Interface),
    Method(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Method),
    Module(codegen_sdk_analyzer::codegen_sdk_typescript::ast::Module),
    ClassRef(codegen_sdk_analyzer::codegen_sdk_typescript::ast::ClassRef),
    TypeRef(codegen_sdk_analyzer::codegen_sdk_typescript::ast::TypeRef),
}
impl Reference {
    pub fn new(
        py: Python<'_>,
        id: codegen_sdk_common::FullyQualifiedName,
        codebase_arc: Arc<GILProtected<codegen_sdk_analyzer::Codebase>>,
    ) -> PyResult<Self> {
        let codebase = codebase_arc.get(py);
        let path = id.file(codebase.db());
        let file = codebase.get_file_for_id(path);
        let file = match file {
            Some(codegen_sdk_analyzer::ParsedFile::Typescript(py)) => py,
            _ => {
                return Err(
                    pyo3::exceptions::PyValueError::new_err(
                        format!(
                            "File not found for path: {}", path.path(codebase.db())
                            .display()
                        ),
                    ),
                );
            }
        };
        let node = file.tree(codebase.db()).get(id.id(codebase.db()));
        if let Some(node) = node {
            match node.as_ref().try_into().unwrap() {
                Class => Ok(Self::Class(Class::new(py, id, codebase_arc))),
                Function => Ok(Self::Function(Function::new(py, id, codebase_arc))),
                Interface => Ok(Self::Interface(Interface::new(py, id, codebase_arc))),
                Method => Ok(Self::Method(Method::new(py, id, codebase_arc))),
                Module => Ok(Self::Module(Module::new(py, id, codebase_arc))),
                ClassRef => Ok(Self::ClassRef(ClassRef::new(py, id, codebase_arc))),
                TypeRef => Ok(Self::TypeRef(TypeRef::new(py, id, codebase_arc))),
            }
        } else {
            Err(pyo3::exceptions::PyValueError::new_err("Node not found"))
        }
    }
}
pub fn register_typescript(
    py: Python<'_>,
    parent_module: &Bound<'_, PyModule>,
) -> PyResult<()> {
    let child_module = PyModule::new(parent_module.py(), "typescript")?;
    child_module.add_class::<TypescriptFile>()?;
    child_module.add_class::<Class>()?;
    child_module.add_class::<Function>()?;
    child_module.add_class::<Interface>()?;
    child_module.add_class::<Method>()?;
    child_module.add_class::<Module>()?;
    child_module.add_class::<ClassRef>()?;
    child_module.add_class::<TypeRef>()?;
    parent_module.add_submodule(&child_module)?;
    cst::register_cst(&child_module)?;
    py.import("sys")?
        .getattr("modules")?
        .set_item("codegen_sdk_pink.typescript", child_module)?;
    Ok(())
}
